# Wymagania – Analiza i Plan Implementacji Produkcyjnej SMC Trading Agent

## Wprowadzenie

SMC Trading Agent to zaawansowany system algorytmicznego tradingu implementujący koncepcje Smart Money Concepts (SMC) dla automatycznego handlu kryptowalutami i forex. System składa się z wielu komponentów: Python backend z FastAPI, Rust execution engine, React frontend, Express.js API, oraz integracje z giełdami (Binance, Bybit, Oanda).

Celem tego dokumentu jest przeprowadzenie kompleksowej analizy całego projektu SMC Trading Agent, obejmującej kontekst biznesowy, techniczny, operacyjny oraz jakościowy, a następnie stworzenie szczegółowego planu implementacji produkcyjnej w formacie „copy-paste-ready”. Analiza i plan kładą nacisk na wydajność, niezawodność, determinizm procesów i jakość operacyjną, pomijając wszelkie aspekty związane z bezpieczeństwem i zgodnością.

## Wymagania

### Wymaganie 1: Analiza Context-7

#### User Story 1
Jako Senior Full-Stack Developer i Architekt Systemów Finansowych, chcę przeprowadzić siedmiowarstwową analizę całego projektu SMC Trading Agent (obejmującą kontekst biznesowy, użytkownika, systemowy, kodu, danych, operacyjny, oraz ryzyka technicznego), aby uzyskać pełne zrozumienie funkcjonalne i operacyjne systemu, umożliwiające stworzenie precyzyjnego planu implementacji produkcyjnej z naciskiem na jakość i wydajność.

#### Zakres 1
Analiza musi objąć wszystkie kluczowe aspekty projektu SMC Trading Agent, od celów biznesowych, przez wymagania użytkowników, strukturę systemu, jakość kodu, modele danych, po aspekty operacyjne i techniczne ryzyka, formatowanie musi być zgodne z wymogami jakościowymi i technicznymi, z precyzyjnymi, mierzalnymi kryteriami akceptacji.

#### Założenia 1
1.  Dostęp do pełnej dokumentacji technicznej projektu, w tym do repozytoriów kodu głównych komponentów (Python, Rust, React, Express.js).
2.  Możliwość analizy istniejących konfiguracji infrastruktury (`Terraform`, `Helm`, `Dockerfile`).
3.  Dostęp do historycznych danych operacyjnych i metryk wydajnościowych (jeśli zarejestrowane).

#### Ograniczenia 1
1.  Pomijane są wszelkie aspekty bezpieczeństwa, zgodności z regulacjami, prywatności danych, audytów bezpieczeństwa, polityk retencji danych z perspektywy zgodności.
2.  Analiza skupia się wyłącznie na parametrach jakościowych, wydajnościowych, niezawodnościowych i operacyjnych.
3.  Wykluczone są analizy rynkowe, konkurencji, oraz wszystkie aspekty związane z finansowaniem projektu poza estymacją kosztów operacyjnych infrastruktury.

#### Kryteria Akceptacji 1
1.  WHEN przeprowadzam analizę kontekstu biznesowego THEN system SHALL zidentyfikować kluczowe cele biznesowe projektu, mierzalne wskaźniki sukcesu (KPI), prognozowany zwrot z inwestycji (ROI), oraz dominujące ryzyka operacyjne i rynkowe z naciskiem na zmienność rynkową.
2.  WHEN analizuję kontekst użytkownika THEN system SHALL zmapować kluczowe persony użytkowników (np. Algo Trader, Tech Lead, Product Owner), zdefiniować ich przypadki użycia, prześledzić typowe ścieżki interakcji (user journeys) oraz określić wymagania w zakresie użyteczności i dostępności funkcjonalnej interfejsu użytkownika.
3.  WHEN badam kontekst systemowy THEN system SHALL jednoznacznie zmapować granice systemu, wszystkie zależności od systemów zewnętrznych (giełdy Binance, Bybit, Oanda API, bazy danych), oraz zdefiniować interfejsy komunikacji z nimi, z uwzględnieniem `latency` i `rate limits`.
4.  WHEN oceniam kontekst kodu THEN system SHALL przeanalizować użyte języki programowania (Python, Rust, TypeScript, JavaScript), kluczowe frameworki (FastAPI, React, Express.js), stosowane style kodowania, ocenić ogólną jakość kodu oraz oszacować pokrycie testami jednostkowymi, integracyjnymi, kontraktowymi.
5.  WHEN sprawdzam kontekst danych THEN system SHALL zbadać wszystkie modele danych, schematy, procesy migracji, polityki retencji z perspektywy jakości, spójności i dostępności, jak również obsługę `staleness`, `missing ticks`, `clock skew`.
6.  WHEN analizuję kontekst operacyjny THEN system SHALL ocenić metody `deployment` (Docker, Kubernetes, Terraform), konfiguracje `runtime`, mechanizmy `HA`, `DR`, strategie `scalability` (`autoscaling`, `capacity planning`), oraz szacowane koszty operacyjne infrastruktury.
7.  WHEN badam kontekst ryzyka technicznego THEN system SHALL zidentyfikować potencjalne problemy operacyjne, wąskie gardła wydajnościowe, punkty awarii systemu, ryzyka związane z jakością danych i determinizmem wykonania zleceń.
8.  WHEN analizuję wykorzystanie zasobów THEN system SHALL określić kluczowe metryki zużycia CPU, pamięci, I/O dla głównych komponentów i ich powiązanie z `requests`/`limits` w Kubernetes.
9.  WHEN badam historię zmian THEN system SHALL przeanalizować główne decyzje architektoniczne i procesu refaktoryzacji z perspektywy ich wpływu na wydajność i niezawodność.
10. WHEN analizuję mechanizmy przetwarzania THEN system SHALL zidentyfikować potoki danych, kolejki (FIFO), mechanizmy `retry`, `idempotency`, `atomicity`, oraz obsługę trybów handlu (backtesting, paper, live).
11. WHEN analizuję konfigurację środowisk THEN system SHALL udokumentować zmienne środowiskowe, pliki konfiguracyjne, mechanizmy `ConfigMaps`, i ich wpływ na operacyjność systemów.
12. WHEN badam procesy budowania THEN system SHALL udokumentować wymagania `hermetic builds`, `provenance` (SLSA), pipeline’y CI/CD (bez skanów bezpieczeństwa/licencji), oraz generowanie `SBOM` (`Syft`).
13. WHEN analizuję mechanizmy obsługi błędów THEN system SHALL zebrać informacje o typowych błędach, ich przyczynach i rozwiązaniach z perspektywy jakości i niezawodności.
14. WHEN mapuję przepływy danych THEN system SHALL zmapować ścieżki danych, punkty transformacji, walidacji jakości i potencjalne opóźnienia (`latency`).
15. WHEN planuję procesy odtwarzania THEN system SHALL zidentyfikować kluczowe kroki `DR` i `backup` z perspektywy jakości danych i ciągłości operacyjnej.
16. WHEN oceniam zależności THEN system SHALL sporządzić listę zależności z ich wersjami i ich wpływem na stabilność i wydajność.
17. WHEN analizuję obsługę zdarzeń THEN system SHALL udokumentować mechanizmy reakcji na zdarzenia giełdowe i wewnętrzne, oraz `maintenance windows handling`.
18. WHEN dokumentuję algorytmy THEN system SHALL opisać kluczowe algorytmy (SMC, sizing) ich założenia i metryki wydajności.
19. WHEN analizuję interfejsy API THEN system SHALL opisać kontrakty API, `rate limits` i polityki `retry` giełd.
20. WHEN badam wydajność THEN system SHALL oszacować `latency` i przepustowość kluczowych operacji.

#### Definition of Done 1
Kompletna analiza wszystkich siedmiu warstw kontekstu, udokumentowana w języku polskim z angielską terminologią techniczną, zawierająca mierzalne kryteria akceptacji, definicje jakościowe, mapowanie ograniczeń systemowych i identyfikację ryzyk technicznych i operacyjnych, z całkowitym pominięciem wszelkich kwestii związanych z bezpieczeństwem i zgodnością.

#### KPI / OKR 1
- **KPI**: Liczba zidentyfikowanych ryzyk operacyjnych: > 5; Liczba zmapowanych zewnętrznych zależności: > 10; Oszacowane pokrycie testami kluczowych modułów: > 70%; Liczba zidentyfikowanych wąskich gardeł wydajności: minimum 3.
- **OKR**: Zakończenie analizy wszystkich 7 warstw kontekstu z precyzyjnymi kryteriami akceptacji przed upływem terminu ustalonego dla tej fazy analizy.

#### Ryzyka i Mitigacje (Operacyjne) 1
*   **Ryzyko:** Niekompletne zrozumienie całego zakresu danych rynkowych giełd prowadzące do błędów w mapowaniu symboli lub `staleness` danych. **Mitigacja:** Dokładna analiza dokumentacji API każdej giełdy, implementacja walidacji danych i mechanizmów detekcji `staleness`.
*   **Ryzyko:** Niewystarczająca identyfikacja limitów `rate-limit` giełd prowadząca do przejściowego braku możliwości składania zleceń. **Mitigacja:** Wnikliwe zbadanie dokumentacji API pod kątem limitów, implementacja mechanizmów `backoff` i `retry`, monitorowanie użycia limitów.
*   **Ryzyko:** Problemy z determinizmem algorytmów w trybach `backtesting`, `paper trading` vs `live trading` z powodu subtelnych różnic w danych lub logice. **Mitigacja:** Rygorystyczne stosowanie tych samych źródeł danych i logiki przetwarzania w każdym trybie, oraz dokładne testowanie `seed` dla generatorów losowych.

#### Artefakty / Deliverables 1
* Raport analizy Context-7 (biznesowy, użytkownika, systemowy, kodu, danych, operacyjny, ryzyka technicznego).
* Mapy person użytkowników i zmapowane `user journeys`.
* Diagram granicyfikacji systemu (C4 Context Level).
* Raport jakości kodu i pokrycia testami.
* Lista modeli danych, schematów, polityk retencji jakościowej.
* Ocena konfiguracji deployment, HA, DR, skalowania i szacunków kosztów operacyjnych.
* Identyfikacja kluczowych ryzyk technicznych i operacyjnych.

#### Checklisty 1
- [ ] `✅` Zidentyfikowano i udokumentowano kluczowe cele biznesowe i KPI.
- [ ] `✅` Stworzono profile person i zmapowano `user journeys`.
- [ ] `✅` Zmapowano wszystkie systemy zewnętrzne i granice systemu.
- [ ] `✅` Przeprowadzono wstępną ocenę jakości kodu i pokrycia testami.
- [ ] `✅` Udokumentowano główne modele danych i polityki retencji jakościowej.
- [ ] `✅` Oceniono mechanizmy `deployment`, `HA`, `DR` i skalowania.
- [ ] `✅` Zidentyfikowano kluczowe ryzyka techniczne i operacyjne.
- [ ] `✅` Potwierdzono dostępność narzędzi do analizy kodu i metryk.

### Wymaganie 2: Identyfikacja Luk i Problemów

#### User Story 2
Jako Lead DevOps/SRE zorientowany na niezawodność i wydajność, chcę przeprowadzić kompleksowy audyt techniczny całego systemu SMC Trading Agent, aby zidentyfikować wszelkie luki techniczne, wąskie gardła wydajnościowe, problemy ze skalowalnością, długi techniczne i potencjalne punkty awarii, aby móc je systematycznie adresować w planie implementacji pogłębiającym jakość, niezawodność i wydajność operacyjną, pomijając całkowicie kwestie bezpieczeństwa.

#### Zakres 2
Audyt musi kompleksowo objąć wszystkie warstwy aplikacji: infrastrukturę (`Docker`, `Kubernetes`, `Terraform`), backend (`Python`/`FastAPI`, `Rust`), frontend (`React`), API (`Express.js`), oraz zewnętrzne integracje (`giełdy API`, bazy danych), z naciskiem na aspekty jakościowe, niezawodnościowe, wydajnościowe i operacyjne.

#### Założenia 2
1. Dostęp do pełnych kodów źródłowych wszystkich komponentów systemu.
2. Możliwość analizy konfiguracji infrastruktury i `deploymentu`.
3. Dostęp do danych telemetrycznych i logów z działających środowisk (jeśli dostępne do analizy operacyjnej).

#### Ograniczenia 2
1. Analiza koncentruje się wyłącznie na aspektach technicznych, wydajnościowych, niezawodnościowych i operacyjnych działania systemu.
2. Pomijane są wszelkie zagadnienia związane z bezpieczeństwem, zgodnością, audytami bezpieczeństwa, prywatnością, RODO.

#### Kryteria Akceptacji 2
1. WHEN przeprowadzam audyt mechanizmów `deploymentu` THEN system SHALL zidentyfikować i udokumentować wszystkie aspekty związane z procesami budowania (`Dockerfile` z optymalizacją obrazu, `hermetic builds`, `non-root user`), testowania (`lint`, `type-check`, `unit`, `integration`, `contract`, `e2e`, `load`, `fuzz`, `chaos`), wdrażania (`branching strategiami` jak Trunk-Based/GitFlow, wersjonowanie, `rollback procedure`), oraz konfiguracji `CI/CD` (przykładowe `GitHub Actions`).
2. WHEN analizuję wydajność systemu THEN system SHALL wykryć i udokumentować wąskie gardła wydajnościowe (np. nieoptymalne zapytania do baz danych, `requests`/`limits` w Kubernetes, `CPU`/`memory`/`IO` utilization), problemy ze skalowaniem (`autoscaling`, `capacity planning`), `latency` w komunikacji (`Python-Rust`), oraz problemy z `determinism` w trybach tradingu.
3. WHEN oceniam jakość i architekturę kodu THEN system SHALL zidentyfikować i udokumentować wszystkie długoterminowe długi techniczne, niekonsekwencje w `styleguide`, braki (lub niską jakość) testów (jednostkowych, integracyjnych, kontraktowych), oraz obszary kodu utrudniające `maintenance`.
4. WHEN sprawdzam konfigurację infrastruktury THEN system SHALL wykryć i udokumentować problemy z konfiguracją kontenerów (`Docker`), orkiestracją (`Kubernetes` - `Deployments`, `Services`, `HPAs`, `PDBs`, `ConfigMaps`), `Sieciowością` (operacyjną, bez `NetworkPolicy`), zarządzaniem stanem (`remote state`, `drift detection` w `Terraform`), oraz systemami `observability` (`Prometheus`, `Grafana`, `OpenTelemetry`).
5. WHEN badam interakcje z zewnętrznymi API THEN system SHALL zidentyfikować i udokumentować problemy z obsługą `rate_limits`, mechanizmami `retry` i `idempotency`, `data staleness`, `missing ticks`, `clock skew` (NTP), `outliers`, `OHLCV consistency`, `pagination`, `symbol mapping`, `maintenance windows`, oraz błędami jakości danych.
6. WHEN analizuję system testowania THEN system SHALL ocenić kompletność i jakość testów (unit, integration, contract, e2e, load, fuzz, chaos), zidentyfikować brakujące obszary pokrycia, oraz problemy ze stabilnością lub `determinism` istniejących testów.
7. WHEN sprawdzam mechanizmy obsługi błędów i niezawodności THEN system SHALL zidentyfikować i udokumentować problemy z determinizmem zleceń, obsługą `partial fills`, duplikatów, modelowaniem kolejki/FIFO, `kill switch`, `circuit breaker`, `rate-limit guard`, `max drawdown guard` [1.5%/5%], `exposure limits`, `position sizing`, `risk per trade` [0.5%], `max daily loss` [2.0%], `trading halt/resume`, oraz procedurami `backup/DR`.
8. WHEN analizuję procesy CI/CD THEN system SHALL zidentyfikować i udokumentować problemy z `branching strategiami` (trunk-based/GitFlow), brakami w `quality gates` (lint, type-check, unit, integration, contract, e2e, load, fuzz, chaos), problemami z `reproducible builds`, brakiem `provenance` (SLSA), oraz nieefektywnością releasu.
9. WHEN badam mechanizmy obserwowalności THEN system SHALL zidentyfikować i udokumentować braki konfiguracyjne w `Prometheus`, `Grafana`, `Alertmanager` (z playbookami), `OpenTelemetry` (logi JSON, trace’y, korelacja `trace_id`), oraz nieprawidłowo zdefiniowane metryki techniczne i biznesowe dla `SLO/SLA/SLI`.
10. WHEN analizuję zarządzanie danymi THEN system SHALL zidentyfikować problemy ze schematami, migracjami, wersjonowaniem, `gatingiem zgodności schematu`, retencją, `backupem`, testami odtwarzania, walidacją jakości danych, katalogami danych i `lineage` z perspektywy jakości i operacyjności.
11. WHEN oceniam wydajność infrastruktury THEN system SHALL zidentyfikować problemy z estymatami kosztów, `capacity planning`, `autoscaling`, konfiguracją `requests`/`limits` w Kubernetes, oraz nieoptymalnym wykorzystaniem zasobów.
12. WHEN analizuję dokumentację i styl kodowania THEN system SHALL zidentyfikować braki w dokumentacji (API, styleguide, ADR, runbooks, guides), niekonsekwencje w stylach kodowania, i brak użycia mierzalnych kryteriów jakościowych.
13. WHEN badam obsługę trybów handlu THEN system SHALL zidentyfikować problemy z implementacją `backtesting`, `paper trading`, `shadow trading`, `dry-run`, `canary`, `blue/green` w kontekście ich determinizmu i izolacji.
14. WHEN analizuję parametry handlowe THEN system SHALL zidentyfikować nieoptymalne ustawienia `SLA` [ms] dla `p50/p95/p99`, budżety `slippage` [bps], problemy z minimalną precyzją, lotami, mapowaniem symboli, oraz obsługą `maintenance windows`.
15. WHEN sprawdzam mechanizmy sterowania ryzykiem THEN system SHALL zidentyfikować problemy z implementacją i walidacją `max_drawdown_guard` [1.5%/5%], `exposure_limits`, `position_sizing`, `risk_per_trade` [0.5%], `max_daily_loss` [2.0%], oraz procedurami `trading halt/resume`.
16. WHEN analizuję mechanizmy komunikacji THEN system SHALL zidentyfikować problemy z `latency`, przepustowością, handlingiem błędów i spójnością danych między komponentami.
17. WHEN badam obsługę błędów jakości danych THEN system SHALL zidentyfikować problemy ze `staleness`, `missing ticks`, `clock skew` (NTP), `outliers`, `OHLCV consistency`, oraz obsługą `retry` i duplikatów.
18. WHEN analizuję strategie ładowania danych THEN system SHALL zidentyfikować problemy z `pagination`, deduplikacją, oraz walidacją danych przychodzących.
19. WHEN sprawdzam mechanizmy zarządzania zleceniami THEN system SHALL zidentyfikować problemy z atomowością transakcji, anulowaniem zleceń, `TIF` (GTC/IOC/FOK), oraz `precision` zleceń.
20. WHEN analizuję pipeline’y CI THEN system SHALL zidentyfikować problemy z hermetycznością buildów, brakami `provenance`(SLSA), oraz nieefektywnością releasu.

#### Definition of Done 2
Szczegółowy raport audytowy zidentyfikowany i udokumentowany, zawierający analizę luk technicznych, wąskich gardeł wydajnościowych, problemów ze skalowalnością, długów technicznych, potencjalnych punktów awarii, braków w testach oraz problemów CI/CD i jakości danych, wraz z propozycjami konkretnych, mierzalnych ulepszeń, bez jakichkolwiek odniesień do aspektów bezpieczeństwa lub zgodności.

#### KPI / OKR 2
- **KPI**: Liczba zidentyfikowanych wąskich gardeł wydajności: > 5; Liczba zidentyfikowanych długów technicznych: > 10; Pokrycie testami kluczowych modułów: > 80%; Liczba zidentyfikowanych problemów niezawodnościowych: > 5; Procent udokumentowanych luk: 100%.
- **OKR**: Zakończenie kompleksowego audytu technicznego wszystkich warstw systemu, identyfikacja i udokumentowanie wszystkich kluczowych problemów technicznych i operacyjnych wraz z propozycjami rozwiązań, przed końcem wyznaczonego cyklu pracy.

#### Ryzyka i Mitigacje (Operacyjne) 2
*   **Ryzyko:** Niewystarczająca głębokość analizy kodu przy braku dostępu do środowiska do uruchomienia testów. **Mitigacja:** Wykorzystanie narzędzi do statycznej analizy kodu, ręczne przeglądy kluczowych fragmentów kodu i testów.
*   **Ryzyko:** Subiektywna ocena jakości kodu i długów technicznych. **Mitigacja:** Zastosowanie predefiniowanych kryteriów oceny (np. czytelność, nazewnictwo, złożoność cyklomatyczna) i porównanie kodu z najlepszymi praktykami.
*   **Ryzyko:** Pominięcie krytycznych zależności operacyjnych w analizie infrastruktury. **Mitigacja:** Korzystanie z diagramów architektury (C4) do weryfikacji powiązań i analizy `Dockerfile`/`Helm Charts`.

#### Artefakty / Deliverables 2
* Raport audytu technicznego zawierający listę zidentyfikowanych luk, problemy z wydajnością, skalowalnością, długi techniczne, punkty awarii, braki w pokryciu testami, problemy CI/CD, jakość danych oraz propozycje rozwiązań.
* Lista obszarów kodu z wysokim długiem technicznym.
* Mapa wąskich gardeł wydajnościowych.
* Zalecenia dotyczące usprawnień w procesach CI/CD i testowania.

#### Checklisty 2
- [ ] `✅` Przeanalizowano i udokumentowano problemy z `deploymentem` i `CI/CD`.
- [ ] `✅` Zidentyfikowano i udokumentowano wąskie gardła wydajnościowe systemu.
- [ ] `✅` Skatalogowano długi techniczne i obszary ryzyka związane z jakością kodu.
- [ ] `✅` Przeanalizowano pokrycie testami i zidentyfikowano braki lub problemy z ich `determinismem`.
- [ ] `✅` Wykryto i udokumentowano problemy z mechanizmami `retry`, `idempotency` i obsługą błędów giełdowych.
- [ ] `✅` Poprawnie przeanalizowano i udokumentowano problemy z konfiguracją infrastruktury pod kątem jakości, niezawodności i skalowalności.
- [ ] `✅` Zidentyfikowano i udokumentowano problemy z zarządzaniem danymi dot. jakości, retencji i spójności.
- [ ] `✅` Udokumentowano braki w mechanizmach obserwowalności i alertowania.
- [ ] `✅` Przeanalizowano i udokumentowano problemy z mechanizmami handlu (tryby, `kill switch`, `drawdown guard`, etc.).
- [ ] `✅` Zidentyfikowano i udokumentowano problemy z interakcjami z API zewnętrznymi i ich ograniczeniami operacyjnymi.

### Wymaganie 3: Plan Implementacji Produkcyjnej

#### User Story 3
Jako Tech Lead zorientowany na produkcję, chcę otrzymać szczegółowy, wykonalny plan implementacji obejmujący wszystkie niezbędne aspekty produkcyjnej aplikacji SMC Trading Agent, w tym konfigurację całej infrastruktury (Docker, Kubernetes, Terraform), integracje z systemami zewnętrznymi (giełdy API, bazy danych), kompleksowy monitoring (Prometheus, Grafana, Alerting), szczegółowe procedury runbook, oraz architekturę skalowalności, wszystko udokumentowane w formacie "copy-paste-ready", z naciskiem na maksymalną jakość, wydajność i niezawodność operacyjną, z całkowitym pominięciem wszelkich wytycznych bezpieczeństwa lub zgodności.

#### Zakres 3
Plan musi kompleksowo obejmować wszystkie etapy od przygotowania infrastruktury, przez implementację kluczowych funkcji i integracji, po konfigurację operacyjną i narzędzia wspomagające niezawodność i wydajność, zgodnie z najlepszymi praktykami inżynierskimi i operacyjnymi.

#### Założenia 3
1. Dostęp do infrastruktury chmurowej (np. AWS, GCP, Azure) lub lokalnego środowiska do wdrożenia (np. Kubernetes z `ingress controller`).
2. Posiadanie kluczy API do giełd i innych niezbędnych usług zewnętrznych potrzebnych do integracji, zgodnie z ich specyfikacją komunikacji.
3. Zespół deweloperski i operacyjny gotowy do wdrożenia i utrzymania systemu zgodnie z dostarczonym planem.

#### Ograniczenia 3
1. Wszelkie aspekty związane z bezpieczeństwem, uprawnieniami, uwierzytelnianiem dostępu, politykami zgodności i audytami są całkowicie pomijane.
2. Koncentracja wyłącznie na aspektach technicznych, operacyjnych, wydajnościowych i niezawodnościowych.
3. Plan musi być gotowy do bezpośredniego przekazania do implementacji i być w pełni wykonalny.

#### Kryteria Akceptacji 3
1. WHEN tworzę plan infrastruktury THEN system SHALL zawierać kompletne i gotowe do użycia `Dockerfile` (minimal base images, non-root user jako optymalizacja uruchomienia) dla głównych komponentów (Python backend, Rust engine, React frontend, Express API), przykładowy `Helm Chart` (Deployment, Service, HPA, PDB, ConfigMap – bez RBAC/NetworkPolicy/PodSecurity), oraz podstawowe pliki `Terraform` (VPC, Cluster, `remote state`, `drift detection`, bez VPC security groups/firewalls).
2. WHEN planuję integracje THEN system SHALL zawierać szczegółowe konfiguracje stubów lub fragmenty kodu implementujące integracje z API giełd (Binance, Bybit, Oanda), bazami danych (np. PostgreSQL z `patroni` dla HA), z naciskiem na `retry`, `idempotencyjność`, `pagination`, `symbol mapping`, `maintenance windows handling`, `data staleness detection`, oraz `clock skew` monitoring.
3. WHEN projektuję system monitoringu THEN system SHALL zawierać konfiguracje `Prometheus` (metryki techniczne i biznesowe), `Grafana` (dashboardy), `Alertmanager` (alerty SLO związane z niezawodnością i wydajnością), oraz `OpenTelemetry` (logi JSON z trace_id, korelacja do X-Request-ID giełd), zgodnie z najlepszymi praktykami obserwowalności.
4. WHEN tworzę runbooki THEN system SHALL zawierać procedury krok po kroku dla typowych incydentów operacyjnych (np. `circuit breaker triggered`, `rate-limit exhaustion`, `stuck order`, `rollback procedure`, `data staleness handling`, `trading halt/resume`), z przykładami komend (`kubectl`, `helm`, `terraform`, `gh`, `syft`), pomijając scenariusze bezpieczeństwa.
5. WHEN planuję mechanizmy zarządzania ryzykiem i handel THEN system SHALL zawierać konfiguracje dla trybów (backtesting, paper, shadow, dry-run, canary, blue/green), `kill switch`, `circuit breaker`, `rate-limit guard`, `max drawdown guard` [1.5%/5%], `exposure limits`, `position sizing`, `risk per trade` [0.5%], `max daily loss` [2.0%], oraz procedur `trading halt/resume`.
6. WHEN projektuję strategię skalowania THEN system SHALL zawierać konfigurację `autoscaling` (HPA), `capacity planning`, `requests`/`limits` w Kubernetes, techniki profilowania CPU/memory/IO, oraz optymalizacje kosztów (`FinOps`).
7. WHEN tworzę dokumentację operacyjną THEN system SHALL zawierać przewodniki wdrożeniowe, `operational guides`, procedury `backup/restore`, FAQ operacyjne, `glossary`, z naciskiem na jakość, niezawodność i wydajność.
8. WHEN definiuję procesy CI/CD THEN system SHALL zawierać konfigurację `GitHub Actions` (build, testy [unit, integration, contract, e2e, load, fuzz, chaos], release), `branching strategiami` (trunk-based/GitFlow), `hermetic builds`, `provenance` (SLSA), komendy `SBOM (Syft)`.
9. WHEN definiuję procesy zarządzania danymi THEN system SHALL zawierać wytyczne dotyczące schematów, migracji, wersjonowania, `gatingu zgodności schematu`, retencji, `backupu`, testów odtwarzania, walidacji jakości danych, katalogów i `lineage`, z perspektywy jakości i operacyjności.
10. WHEN opisuję mechanizmy obsługi zleceń THEN system SHALL zawierać wytyczne dotyczące budżetów `latency` [ms] (p50/p95/p99), kontroli `slippage` [bps], obsługi `TIF` (GTC/IOC/FOK), precyzji tick/lot, atomowości transakcji, `FIFO` queueding, oraz anulowania zleceń.
11. WHEN planuję obsługę danych THEN system SHALL zawierać strategie dotyczące `staleness`, `missing ticks`, `clock skew` (NTP), `outliers`, `OHLCV consistency`, `retry`, `idempotency`, obsługi duplikatów/partial fills, oraz zgodności z `rate-limits` giełd.
12. WHEN opisuję interfejsy API THEN system SHALL zawierać snippet `OpenAPI` dla FastAPI backendu i przykładowe kontrakty API dla giełd.
13. WHEN planuję zarządzanie stanem konfiguracji THEN system SHALL zawierać przykłady `ConfigMaps` i strategii zarządzania zmiennymi środowiskowymi.
14. WHEN system zawiera testy `chaos` THEN musi być on możliwy do konfiguracji i uruchomienia bez modyfikacji głównej logiki aplikacji.
15. WHEN system zawiera algorytmy `position sizing` THEN musi być możliwa ich konfiguracja i walidacja.
16. WHEN system obsługuje `trading halt/resume` THEN musi to być realizowane przez mechanizmy niezależne od platformy deploymentu.
17. WHEN system analizuje dane THEN musi pozwalać na łatwe ładowanie okresów danych i obsługę `pagination`.
18. WHEN system zawiera `runbooki` THEN muszą one być gotowe do użycia i zawierać konkretne komendy operacyjne.
19. WHEN system zarządza logami THEN musi być dostępna konfiguracja dla `logi JSON` z `trace_id` i propozycje integracji z systemami zbierania logów.
20. WHEN planuję walidację danych THEN system SHALL zawierać strategię walidacji danych przychodzących i obsługi błędów.

#### Definition of Done 3
Kompletny, szczegółowy i wykonalny plan implementacji produkcyjnej, obejmujący konfigurację infrastruktury, integracji, monitoringu, runbooki, strategię skalowania, dokumentację operacyjną, plan CI/CD, zarządzanie danymi i mechanizmy handlowe, wszystko w formacie "copy-paste-ready", z całkowitym pominięciem aspektów bezpieczeństwa i zgodności.

#### KPI / OKR 3
- **KPI**: % ukończenia planu dla każdego komponentu: 100%; Dokładność estymacji kosztów: ±15%; Średni czas rollbacku: < 10 minut; `RTO (Recovery Time Objective)`: < 1 godzinę.
- **OKR**: Dostarczenie kompletnego planu implementacji produkcyjnej, obejmującego wszystkie elementy od infrastruktury po gotowe runbooki, zintegrowanego z narzędziami deweloperskimi i operacyjnymi, przed końcem sprintu dedykowanego planowaniu.

#### Ryzyka i Mitigacje (Operacyjne) 3
*   **Ryzyko:** Niewystarczająca precyzja w estymacji kosztów infrastruktury. **Mitigacja:** Użycie narzędzi do `capacity planning` i `FinOps`, konsultacja bazowych cenników dostawców chmur.
*   **Ryzyko:** Zbyt wysokie zależności między komponentami, utrudniające niezależne `deployment`. **Mitigacja:** Dążenie do luźnego powiązania i stosowanie `event-driven` komunikacji tam, gdzie to możliwe.
*   **Ryzyko:** Problemy z odtwarzalnością `buildów` (`reproducible builds`) wpływające na spójność artefaktów. **Mitigacja:** Zastosowanie `hermetic builds` i `SBOM generation` dla każdego artefaktu.

#### Artefakty / Deliverables 3
*   Zestaw gotowych plików konfiguracyjnych: `Dockerfile` (API, Engine, Frontend), `example.helm.yml`, `example_terraform.tf`, `ci-cd-template.yml`, `prometheus_rules.yml`, `grafana_dashboard.json`, `otel-collector-config.yaml`, `openapi-3.0.yaml`, `slo-alerts.prom`, `sbom-syft-command.sh`.
*   Szczegółowe runbooki dla typowych zdarzeń operacyjnych.
*   Plan testów obejmujący: matrycę testów, kryteria wejścia/wyjścia, dane testowe, regresje, smoke tests.
*   Definicje `SLO/SLA/SLI` wraz z przykładowymi zapytaniami PromQL.
*   Estymaty kosztów i harmonogram faz implementacji.

#### Checklisty 3
- [ ] `✅` Wygenerowano kompletne `Dockerfiles` dla wszystkich głównych komponentów z optymalizacjami.
- [ ] `✅` Przygotowano przykładowy `Helm Chart` dla Kubernetes.
- [ ] `✅` Stworzono podstawowe pliki `Terraform` do zarządzania infrastrukturą.
- [ ] `✅` Skonfigurowano monitoring przez `Prometheus`/`Grafana`/`Alertmanager`/`OpenTelemetry`.
- [ ] `✅` Udokumentowano `runbooki` dla kluczowych incydentów operacyjnych.
- [ ] `✅` Oszacowano koszty infrastruktury i zaplanowano harmonogram.
- [ ] `✅` Zdefiniowano metryki techniczne i biznesowe dla `SLO/SLA/SLI`.
- [ ] `✅` Udokumentowano mechanizmy zarządzania ryzykiem i tryby handlu.
- [ ] `✅` Opisano strategie zarządzania danymi pod kątem jakości i `backup`/`restore`.
- [ ] `✅` Zaplanowano i udokumentowano procesy CI/CD z uwzględnieniem `qualitiy gates`.

### Wymaganie 4: Weryfikacja i Walidacja

#### User Story 4
Jako Architekt Systemów Finansowych i Główny Inżynier ds. Niezawodności, chcę mieć absolutną pewność, że wszystkie rekomendacje techniczne, dotyczące wydajności, niezawodności i jakości danych, są oparte na najnowszych, oficjalnych źródłach dokumentacji oraz najlepszych praktykach branżowych w obszarze operacyjnym, aby zagwarantować maksymalną jakość i stabilność produkcyjnego systemu SMC Trading Agent.

#### Zakres 4
Weryfikacja musi obejmować wszystkie dostarczone rekomendacje techniczne, konfiguracje i plany, z odniesieniem do najnowszych wersji dokumentacji technicznych używanych technologii i API, skupiając się na aspektach jakościowych i operacyjnych.

#### Założenia 4
1. Dostęp do oficjalnej dokumentacji wszystkich używanych technologii (najnowsze dostępne stabilne wersje).
2. Możliwość weryfikacji zgodności sugerowanych rozwiązań z najlepszymi praktykami branżowymi w obszarze operacyjnym.

#### Ograniczenia 4
1. Pomijanie wszelkich standardów, dokumentacji lub rekomendacji związanych z bezpieczeństwem, zgodnością, prywatnością.
2. Skupienie wyłącznie na potwierdzeniu jakości technicznej, wydajności, niezawodności, determinizmu procesów i najlepszych praktyk operacyjnych.
3. W celu zapewnienia aktualności, preferowane są linki do dokumentacji online z bieżącego roku.

#### Kryteria Akceptacji 4
1. WHEN podaję rekomendacje dotyczące orchestracji (Kubernetes, Helm) THEN system SHALL cytować oficjalną dokumentację Kubernetes i Helm, wskazując na najlepsze praktyki dla `Deployments`, `Services`, `HPAs`, `PDBs`, `ConfigMaps` w kontekście niezawodności i skalowalności [np. Dokumentacja Kubernetes v1.30].
2. WHEN sugeruję optymalizacje wydajnościowe THEN system SHALL odwoływać się do oficjalnych przewodników wydajnościowych używanych technologii [np. Rust Performance Book, FastAPI Performance Docs, React Docs].
3. WHEN rekomenduję konfigurację monitoringu (Prometheus, Grafana) THEN system SHALL odwoływać się do aktualnej dokumentacji tych narzędzi, podając przykłady metryk i konfiguracji alertów zgodnych z najlepszymi praktykami obserwowalności [np. Prometheus Best Practices v2.49].
4. WHEN tworzę przykładowe skrypty CI/CD (GitHub Actions) THEN system SHALL zawierać komendy i konfiguracje zgodne z najnowszymi wersjami używanych CLI (`docker`, `kubectl`, `helm`, `terraform`, `gh`, `syft`) i standardami CI/CD [np. GitHub Actions Runner v4 docs].
5. WHEN definiuję polityki retencji i backupu danych THEN system SHALL opierać się na dokumentacji systemów bazodanowych (np. PostgreSQL) i narzędzi backupowych, podkreślając procedury odzyskiwania w kontekście jakości danych [np. PostgreSQL 16 Backup Docs].
6. WHEN planuję mechanizmy obsługi zleceń THEN system SHALL odwoływać się do dokumentacji API giełd (Binance, Bybit, Oanda) i najlepszych praktyk w algorytmicznym tradingu pod kątem determinizmu i niezawodności [np. Binance API v1.3 Documentation].
7. WHEN proponuję strategie obsługi błędów jakości danych THEN system SHALL odwoływać się do dokumentacji giełd i najlepszych praktyk zarządzania danymi strumieniowymi, wspominając o `NTP` dla synchronizacji czasu [np. Bybit API v5 Documentation].
8. WHEN rekomenduję tryby handlu THEN system SHALL opierać się na dokumentacji używanych frameworków (np. `vectorized backtester`) i najlepszych praktykach walidacji strategii [np. Pandas TA Docs].
9. WHEN planuję skalowanie THEN system SHALL bazować na oficjalnej dokumentacji Kubernetes i używanego Cloud Providera [np. Kubernetes HPA Docs, AWS EKS Docs].
10. WHEN tworzę estymaty kosztów THEN system SHALL opierać się na dokumentacji cenowej usług chmurowych i narzędziach `FinOps`, z podaniem założeń walutowych [PLN/USD].
11. WHEN tworzę runbooki THEN system SHALL zawierać aktualne komendy dla narzędzi operacyjnych (`kubectl`, `helm`, `terraform`, `gh`), zgodne z ich dokumentacją [np. kubectl v1.30 Cheat Sheet].
12. WHEN definiuję metryki THEN system SHALL cytować najlepsze praktyki SRE i przykładowe zapytania dla `Prometheus` oraz opis `Grafana dashboards` [np. Prometheus Best Practices].
13. WHEN opisuję procesy budowania i `provenance` THEN system SHALL opierać się na dokumentacji narzędzi `Syft` i `cosign`, odnośnie integralności i powtarzalności.
14. WHEN opisuję mechanizmy obsługi błędów THEN system SHALL bazować na oficjalnych dokumentacjach języków i frameworków (Python, Rust, JS/TS) odnośnie najlepszych praktyk.
15. WHEN dokumentuję kontrakty API THEN system SHALL używać formatów zgodnych z najnowszymi wersjami `OpenAPI Specification` lub `GraphQL Schema Definition Language`.
16. WHEN planuję walidację danych THEN system SHALL odwoływać się do dokumentacji używanych schematów (`Pydantic`, `Zod`) i ich funkcji walidacyjnych.
17. WHEN sugeruję rozwiązania do `managementu okien serwisowych` THEN system SHALL opierać się na dokumentacji giełd i mechanizmach komunikacji z nimi.
18. WHEN opisuję strategie zarządzania danymi THEN system SHALL odwoływać się do rekomendacji producentów baz danych (np. PostgreSQL) w zakresie jakości i sprawności.
19. WHEN proponuję metody optymalizacji CPU/memory/IO THEN system SHALL cytować dokumentację narzędzi profilujących i systemu operacyjnego.
20. WHEN opisuję procedury `trading halt/resume` THEN system SHALL zawierać odwołania do dokumentacji API giełd lub mechanizmów zarządzania handlem.

#### Definition of Done 4
Pełna weryfikacja wszystkich rekomendacji i artefaktów pod kątem zgodności z aktualną oficjalną dokumentacją techniczną i najlepszymi praktykami operacyjnymi, z pominięciem wszelkich aspektów bezpieczeństwa.

#### KPI / OKR 4
- **KPI**: Liczba cytowanych oficjalnych źródeł dokumentacji na kryterium: ≥ 2; % kryteriów z adnotacją `[do weryfikacji]`: < 10%; % kryteriów z pominiętymi aspektami bezpieczeństwa: 100%.
- **OKR**: Kompletna weryfikacja wszystkich zaleceń i artefaktów przed końcem cyklu pracy, potwierdzająca ich techniczną poprawność i zgodność z wytycznymi operacyjnymi.

#### Ryzyka i Mitigacje (Operacyjne) 4
*   **Ryzyko:** Dostępność nieaktualnej dokumentacji API giełd lub frameworków. **Mitigacja:** Weryfikacja dat publikacji dokumentacji i priorytetyzacja najnowszych stabilnych wersji.
*   **Ryzyko:** Błędna interpretacja najlepszych praktyk operacyjnych bez kontekstu całego systemu. **Mitigacja:** Analiza pod kątem wpływu na niezawodność i wydajność całego systemu, a nie tylko pojedynczego komponentu.
*   **Ryzyko:** Pośrednie zależności od nieudokumentowanych lub przestarzałych funkcji. **Mitigacja:** Dokładna analiza drzewa zależności i weryfikacja dokumentacji dla każdej warstwy.

#### Artefakty / Deliverables 4
* Lista cytowanych oficjalnych źródeł dokumentacji dla każdej rekomendacji.
* Potwierdzenie zgodności ze standardami operacyjnymi, wydajnościowymi i niezawodnościowymi.
* Zaznaczenie obszarów wymagających dalszej weryfikacji (`[do weryfikacji]`).

#### Checklisty 4
- [ ] `✅` Zweryfikowano rekomendacje dotyczące orchestracji (Kubernetes, Helm) z oficjalną dokumentacją.
- [ ] `✅` Zweryfikowano optymalizacje wydajnościowe z dokumentacją technologii.
- [ ] `✅` Zweryfikowano konfiguracje monitoringu z dokumentacją `Prometheus`/`Grafana`.
- [ ] `✅` Zweryfikowano skrypty CI/CD z dokumentacją używanych narzędzi.
- [ ] `✅` Zweryfikowano polityki retencji danych z dokumentacją baz danych.
- [ ] `✅` Zweryfikowano mechanizmy obsługi zleceń z dokumentacją API giełd.
- [ ] `✅` Zweryfikowano strategie obsługi błędów jakości danych z dokumentacją giełd.
- [ ] `✅` Zweryfikowano tryby handlu z dokumentacją frameworków.
- [ ] `✅` Zweryfikowano strategie skalowania z dokumentacją Kubernetes/Cloud.
- [ ] `✅` Zweryfikowano estymaty kosztów z dokumentacją dostawców chmur/narzędzi.
- [ ] `✅` Zweryfikowano komendy runbooków z dokumentacją CLI.
- [ ] `✅` Zweryfikowano definicje metryk i SLO z najlepszymi praktykami SRE.
- [ ] `✅` Zweryfikowano procesy budowania i `provenance` z dokumentacją narzędzi.
- [ ] `✅` Zweryfikowano mechanizmy obsługi błędów języków i frameworków.
- [ ] `✅` Zweryfikowano kontrakty API z dokumentacją OpenAPI/GraphQL.
- [ ] `✅` Zweryfikowano schematy danych z dokumentacją walidacyjną.
- [ ] `✅` Zweryfikowano mechanizmy `managementu okien serwisowych` z dokumentacją giełd.
- [ ] `✅` Zweryfikowano strategie zarządzania danymi z dokumentacją baz danych.
- [ ] `✅` Zweryfikowano metody optymalizacji zasobów.
- [ ] `✅` Zweryfikowano definicje procedur `trading halt/resume`.

### Wymaganie 5: Deliverables i Format

#### User Story 5
Jako doświadczony Product Owner, zarządzający portfelem algorytmicznych strategii tradingowych, chcę otrzymać wyniki analizy i planu implementacji w ściśle strukturyzowanym formacie, zawierającym precyzyjne diagramy (Mermaid), dogłębne checklisty z konkretnymi komendami, gotowe do bezpośredniego wdrożenia artefakty konfiguracyjne i operacyjne, realistyczne estymaty kosztów i harmonogram, oraz jasno zdefiniowane metryki niezawodności i wydajności, wszystko w języku polskim z zachowaniem angielskiej terminologii technicznej i standardów branżowych, z całkowitym pominięciem wszelkich aspektów bezpieczeństwa i zgodności.

#### Zakres 5
Dostarczenie kompletnego zestawu artefaktów i dokumentacji zgodnego z wytycznymi: w języku polskim, z angielską terminologią techniczną, w formacie "copy-paste-ready", zawierającego wszystkie wymagane sekcje, diagramy, konfiguracje, plany testów, runbooki, definicje metryk, estymaty kosztów i harmonogram, z pominięciem wszelkich zagadnień bezpieczeństwa.

#### Założenia 5
1. Dostęp do wszystkich narzędzi wymaganych do generowania proponowanych artefaktów (Mermaid, `Dockerfile`, `Helm`, `Terraform`, `GitHub Actions`, `Prometheus`, `Grafana`, `OpenTelemetry`, `Syft`).
2. Potwierdzenie, że przedstawione artefakty są zgodne z aktualnymi wersjami technologii i najlepszymi praktykami operacyjnymi.

#### Ograniczenia 5
1. Wykluczenie wszelkich artefaktów, konfiguracji lub procedur mających związek z bezpieczeństwem, zgodnością z regulacjami, prywatnością, audytami bezpieczeństwa.
2. Wszystkie artefakty muszą być funkcjonalne i gotowe do użycia "copy-paste", z poprawną składnią i parametrami.
3. Diagramy muszą być renderowalne przez narzędzia obsługujące Mermaid.

#### Kryteria Akceptacji 5
1. WHEN dostarczam analizę Context-7 THEN system SHALL zawrzeć kompletne, 7 uporządkowanych sekcji analizy z precyzyjnymi findings i konkretnymi obserwacjami.
2. WHEN tworzę diagramy THEN system SHALL używać `Mermaid` dla architektury C4 (Context, Container, Component), przepływu danych i sekwencji zleceń, z polskimi opisami i angielskimi nazwami komponentów.
3. WHEN dostarczam plan implementacji THEN system SHALL zawierać gotowe do użycia pliki konfiguracyjne: `Dockerfile` (API, Engine, Frontend), `example.helm.yml`, `example_terraform.tf`, `ci-cd-template.yml`, `prometheus_rules.yml`, `grafana_dashboard.json`, `otel-collector-config.yaml`, `openapi-3.0.yaml`, `slo-alerts.prom`, `sbom-syft-command.sh`, wszystkie bez konfiguracji bezpieczeństwa.
4. WHEN tworzę checklisty THEN system SHALL zawierać konkretne kroki z komendami i weryfikacją sukcesu (np. `EXPECT p95 < 100ms`).
5. WHEN dokumentuję koszty THEN system SHALL zawierać estymaty dla różnych środowisk (dev/stage/prod) z założeniami walutowymi [PLN]/[USD] i odniesieniem do angielskich nazw zasobów chmurowych.
6. WHEN planuję timeline THEN system SHALL zawierać realistyczny harmonogram z fazami, zależnościami, kamieniami milowymi i kryteriami Go/No-Go, używając angielskich nazw artefaktów i zależności.
7. WHEN dostarczam runbooki THEN system SHALL zawierać procedury krok po kroku dla incydentów operacyjnych (np. `circuit breaker`, `rate-limit exhaustion`, `stuck order`, `rollback`, `data staleness`, `trading halt/resume`), z przykładami komend i oczekiwanymi wynikami, bez aspektów bezpieczeństwa.
8. WHEN definiuję plan testów THEN system SHALL zawierać matrycę testów (unit, integration, contract, e2e, load, fuzz, chaos), kryteria wejścia/wyjścia, dane testowe, seedy, regresje, `smoke tests`, z użyciem angielskich nazw narzędzi.
9. WHEN definiuję metryki THEN system SHALL zawierać listę kluczowych metryk technicznych i biznesowych (`order_latency_p95`, `slippage_bps`, `daily_pnl`, `max_drawdown`, etc.) oraz przykładowe zapytania PromQL.
10. WHEN dokumentuję procesy zarządzania danymi THEN system SHALL zawierać wytyczne dotyczące `schemas`, `migrations`, `versioning`, `data_quality validation`, `retention`, `backup`, `restore tests`, `pagination`, bez odniesień do prywatności czy zgodności.
11. WHEN opisuję konfigurację CI/CD THEN system SHALL zawierać przykłady `GitHub Actions` z komendami `lint`, `type-check`, `build`, `test`, `release`, `SBOM generation` (`Syft`), bez skanów bezpieczeństwa/licencji.
12. WHEN opisuję logowanie i tracing THEN system SHALL zawierać przykłady konfiguracji `logi JSON`, `OpenTelemetry`, korelacji `trace_id` z `X-Request-ID` giełd.
13. WHEN opisuję mechanizmy handlu THEN system SHALL zawierać konfiguracje trybów (backtesting, paper, shadow, dry-run, canary, blue/green), `kill switch`, `circuit breaker`, `rate-limit guard`, `max drawdown guard`, `exposure limits`, `position sizing`, `risk per trade`, `max daily loss`, `trading halt/resume`.
14. WHEN opisuję interfejsy API THEN system SHALL zawierać snippet `OpenAPI` dla FastAPI backendu i przykładowe kontrakty API dla giełd.
15. WHEN tworzę sekcję `QA & Completeness` THEN system SHALL zawierać polskie wypunktowanie uzupełnień i potencjalnych ryzyk techniczno-operacyjnych.
16. WHEN podaję referencje THEN system SHALL zawierać linki wyłącznie do oficjalnej dokumentacji technologii.
17. WHEN podaję komendy THEN system SHALL zawierać wersje CLI i parametry wymagane do poprawnego wykonania (np. `--directory`, wersje specyfikacji).
18. WHEN tworzę artefakty THEN system SHALL omijać wszelkie konfiguracje związane z RBAC, NetworkPolicy, PodSecurity, Vault/KMS, skanami bezpieczeństwa i licencjami.
19. WHEN opisuję skalowanie THEN system SHALL bazować na standardach Kubernetes (`HPA`) i Cloud Providerów.
20. WHEN definiuję procedury `halt/resume` THEN muszą być one niezależne od platformy deploymentu.

#### Definition of Done 5
Kompletny zestaw artefaktów i dokumentacji, zgodny ze wszystkimi wytycznymi formatowania, języka, zakresu i pominięcia aspektów bezpieczeństwa, gotowy do bezpośredniego użycia w procesie implementacji i operacyjnym.

#### KPI / OKR 5
- **KPI**: Liczba artefaktów "copy-paste-ready": > 10; Poprawność składniowa wszystkich artefaktów: 100%; Renderowalność wszystkich diagramów Mermaid: 100%; Zgodność dokumentacji z wytycznymi: 100%.
- **OKR**: Przygotowanie i dostarczenie pełnego zestawu dokumentacji i artefaktów spełniających wszystkie kryteria przed końcem wyznaczonego cyklu pracy.

#### Ryzyka i Mitigacje (Operacyjne) 5
*   **Ryzyko:** Niekompletność lub niepoprawność artefaktów konfiguracyjnych (np. `Helm`, `Terraform`). **Mitigacja:** Weryfikacja składni i kluczowych parametrów artefaktów przed finalnym zapisem.
*   **Ryzyko:** Niedostateczna szczegółowość w runbookach, co utrudnia ich wykonanie. **Mitigacja:** Dodanie konkretnych komend i oczekiwanych wyników do każdego kroku runbooka.
*   **Ryzyko:** Brak uwzględnienia specyfiki różnych środowisk (`dev`, `stage`, `prod`) w konfiguracjach. **Mitigacja:** Wykorzystanie zmiennych środowiskowych i `ConfigMaps`/`Secrets` w sposób umożliwiający łatwe przełączanie konfiguracji.

#### Artefakty / Deliverables 5
* Zestaw gotowych plików: `Dockerfile` (API, Engine, Frontend), `example.helm.yml`, `example_terraform.tf`, `ci-cd-template.yml`, `prometheus_rules.yml`, `grafana_dashboard.json`, `otel-collector-config.yaml`, `openapi-3.0.yaml`, `slo-alerts.prom`, `sbom-syft-command.sh` (przykłady).
* Ponad 120 precyzyjnych Kryteriów Akceptacji dla Wymagań 1-6.
* 3 diagramy C4 Mermaid, 2 diagramy przepływu danych/sekwencji.
* Szczegółowe runbooki i plan testów.
* Definicje metryk i SLO.

#### Checklisty 5
- [ ] `✅` Weryfikacja kompletności i `copy-paste-ready` statusu wszystkich artefaktów konfiguracyjnych i operacyjnych.
- [ ] `✅` Poprawność składniowa i renderowalność wszystkich diagramów Mermaid.
- [ ] `✅` Kompletność i precyzja definicji w kryteriach akceptacji dla Wymagań 1-6.
- [ ] `✅` Zgodność wszystkich dokumentów z wytycznymi dotyczącymi pomijania bezpieczeństwa/zgodności.
- [ ] `✅` Kompletność i poprawność dokumentacji operacyjnej i runbooków.
- [ ] `✅` Zgodność metryk i SLO z definicjami niezawodności i wydajności.
- [ ] `✅` Brak jakiejkolwiek wzmianki o bezpieczeństwie, zgodności, prywatności.

### Wymaganie 6: Język i Lokalizacja

#### User Story 6
Jako Polski Product Owner z doświadczeniem w branży finansowej i tradingu algorytmicznego, chcę otrzymać kompletny dokument wymagań i planu implementacji napisany w języku polskim, który zachowa techniczną precyzję oraz będzie zawierał angielskie nazwy narzędzi, technologii, komend i kodów programowania, aby zapewnić pełne zrozumienie dla polskiego zespołu technicznego przy jednoczesnym zachowaniu standardów branżowych w zakresie terminologii i formatowania, z całkowitym pominięciem wszelkich aspektów związanych z bezpieczeństwem i zgodnością, a skupiającym się na jakości, wydajności i niezawodności.

#### Zakres 6
Stworzenie kompletnego, spójnego i precyzyjnego dokumentu specyfikacji technicznej, który będzie napisany w języku polskim dla opisów i kontekstu, ale zachowa angielską terminologię techniczną, nazwy narzędzi, komendy, fragmenty kodu i nazwy komponentów systemowych, zgodnie z najlepszymi praktykami branżowymi.

#### Założenia 6
1. Głównym językiem dokumentacji jest polski.
2. Angielska terminologia techniczna jest wymagana dla precyzji i zgodności ze standardami globalnymi.
3. Kontekst filmu/sztuki filmowej jest nieistotny; skupiamy się na aspektach finansowych i tradingu algorytmicznego.

#### Ograniczenia 6
1. Całkowite wykluczenie jakichkolwiek odniesień do bezpieczeństwa, zgodności, prywatności, RODO, audytów bezpieczeństwa.
2. Koncentracja wyłącznie na jakości technicznej, wydajności, niezawodności i aspektach operacyjnych.
3. Styl musi być rzeczowy, inżynierski, bez ogólników czy niewypełnionych miejsc ("TBD").

#### Kryteria Akceptacji 6
1. WHEN tworzę dokumentację THEN system SHALL używać języka polskiego dla wszystkich opisów, wyjaśnień i kontekstów narracyjnych.
2. WHEN używam terminologii technicznej THEN system SHALL zachować oryginalne, angielskie nazwy technologii, frameworków, narzędzi, API, bibliotek, jak również komend CLI i fragmentów kodu programowania (np. Python, Rust, FastAPI, React, Docker, Kubernetes, Terraform, Prometheus, Grafana, OpenTelemetry, `kubectl`, `helm`, `npm`, `pytest`, `cargo`).
3. WHEN cytuję fragmenty kodu lub konfiguracji THEN system SHALL używać odpowiednich bloków kodu (```python ... ```, ```rust ... ```, ```bash ... ```, ```yaml ... ```, ```json ... ```) z poprawną, angielską składnią.
4. WHEN tworzę diagramy THEN system SHALL używać `Mermaid` z polskimi opisami elementów, lecz angielskimi nazwami komponentów systemowych i technologii, wraz z polskimi tytułami diagramów.
5. WHEN podaję instrukcje krok po kroku lub komendy THEN system SHALL prezentować je w języku polskim, ale same komendy muszą być w oryginalnej, angielskiej składni i formatowaniu (np. `Run "pytest -m integration --maxfail=1"`).
6. WHEN tworzę listy lub checklisty THEN system SHALL używać polskich opisów zadań i kryteriów, ale odwoływać się do angielskich nazw funkcji, parametrów i artefaktów.
7. WHEN dokumentuję procesy tradingowe THEN system SHALL używać polskich opisów mechanizmów (np. "zarządzanie drawdownem", "rozmiar pozycji"), ale zachować angielskie nazwy parametrów i trybów (np. `max_drawdown_guard`, `position_sizing`, backtesting, paper trading).
8. WHEN tworzę estymaty kosztów THEN system SHALL przedstawiać je w walucie polskiej lub USD z jasnym wskazaniem założeń walutowych i odniesieniem do angielskich nazw usług chmurowych (np. "AWS EC2 instances `t3.medium` estymowany koszt to [X] PLN/USD miesięcznie").
9. WHEN planuję harmonogram THEN system SHALL używać polskich nazw faz i kamieni milowych, ale zależności i nazwy artefaktów muszą być w języku angielskim.
10. WHEN opisuję metryki niezawodności i wydajności THEN system SHALL używać polskich opisów, ale nazwy metryk (`order_latency_p95`, `slippage_bps`) i jednostki muszą być angielskie.
11. WHEN tworzę sekcję `QA & Completeness` THEN system SHALL zawierać polskie opisy uzupełnień i ryzyk, z angielskimi odniesieniami technicznymi.
12. WHEN podaję referencje THEN system SHALL zawierać linki do oficjalnej dokumentacji (zazwyczaj angielskiej), pomijając standardy bezpieczeństwa/zgodności.
13. WHEN podaję komendy THEN system SHALL zawierać `CLI tool names` i parametry w oryginalnej, angielskiej formie.
14. WHEN tworzę artefakty THEN system SHALL omijać wszelkie konfiguracje związane z `RBAC`, `NetworkPolicy`, `PodSecurity`, `Vault/KMS`, skanami bezpieczeństwa i licencjami.
15. WHEN opisuję skalowanie THEN system SHALL preferować standardowe mechanizmy orkiestracji (np. Kubernetes `HPA`) z angielskimi nazwami zasobów.
16. WHEN definiuję procedury `halt/resume` THEN muszą one być opisane dla uniwersalnych mechanizmów operacyjnych, używając angielskich nazw komend.
17. WHEN system zarządza zleceniami THEN logika musi być oddzielona od specyfiki giełd, z uwzględnieniem angielskich nazw typów zleceń (`TIF` - GTC, IOC, FOK).
18. WHEN system zarządza danymi THEN musi używać standardowych formatów (JSON, CSV) i angielskich nazw typów danych.
19. WHEN system zawiera `quality gates` THEN muszą one być łatwe do konfiguracji i zawierać angielskie nazwy parametrów (`lint`, `type-check`, `unit`, `integration`).
20. WHEN system zawiera `runbooki` THEN instrukcje muszą być po polsku, ale komendy i nazwy techniczne w nich zawarte muszą być angielskie.

#### Definition of Done 6
Kompletny dokument specyfikacji technicznej w języku polskim, z integralnie wplecioną angielską terminologią techniczną, narzędziami, komendami i kodem, zgodny z wszystkimi wytycznymi formatowania, struktury i pomijania aspektów bezpieczeństwa/zgodności/prywatności.

#### KPI / OKR 6
- **KPI**: % elementów dokumentacji w języku polskim (opisy): 100%; % elementów technicznych (nazwy technologii, kod, komendy) w języku angielskim: 100%; Zgodność z wytycznymi formatowania i pomijania bezpieczeństwa: 100%.
- **OKR**: Dostarczenie kompletnego, spójnego i precyzyjnego dokumentu spełniającego wszystkie wytyczne językowe i tematyczne przed końcem bieżącej sesji roboczej.

#### Ryzyka i Mitigacje (Operacyjne) 6
*   **Ryzyko:** Niespójne użycie języka polskiego i angielskiego w dokumentacji. **Mitigacja:** Rygorystyczne przestrzeganie reguł dotyczących przypisania języka do typów elementów treści i przeprowadzenie ostatniej weryfikacji.
*   **Ryzyko:** Pominięcie kluczowych technicznych komend lub definicji z powodu rygorystycznego wykluczenia terminów technicznych w polskich opisach. **Mitigacja:** Zapewnienie, że wszystkie techniczne aspekty są przedstawione z użyciem oryginalnej, angielskiej terminologii w odpowiednich miejscach.
*   **Ryzyko:** Niepełne dostarczenie wszystkich wymaganych sekcji i artefaktów z powodu przeoczenia w wytycznych. **Mitigacja:** Ścisłe przestrzeganie listy wymaganych artefaktów i kryteriów akceptacji dla każdego wymogu.

#### Artefakty / Deliverables 6
* Kompletny dokument specyfikacji technicznej w języku polskim.
* Wszystkie wymagane sekcje dodatkowe, diagramy, konfiguracje, plany testów, runbooki, definicje metryk, estymaty kosztów.
* Zgodność ze wszystkimi wytycznymi formatowania i języka.

#### Checklisty 6
- [ ] `✅` Cała dokumentacja napisana w języku polskim, z wyjątkiem terminów technicznych, kodów i komend.
- [ ] `✅` Wszystkie nazwy technologii, frameworków, narzędzi, API, bibliotek są w języku angielskim.
- [ ] `✅` Wszystkie komendy CLI i fragmenty kodu są w języku angielskim i poprawnie sformatowane.
- [ ] `✅` Diagramy Mermaid mają polskie opisy i angielskie nazwy komponentów.
- [ ] `✅` Pominięte zostały wszelkie kwestie bezpieczeństwa, zgodności i prywatności.
- [ ] `✅` Skupiono się na jakości, wydajności, niezawodności i aspektach operacyjnych.
- [ ] `✅` Wszystkie kryteria akceptacji są precyzyjne, mierzalne i zgodne z formatem.
- [ ] `✅` Dostarczono wszystkie wymagane sekcje dodatkowe i artefakty.
- [ ] `✅` Zachowano oryginalny sens i zakres funkcjonalny wymagań.

## 3. NFR - Non-Functional Requirements

### 3.1 Reliability
System SMC Trading Agent musi zapewniać **ciągłą i nieprzerwaną pracę** z minimalnymi przestojami, wysoką spójnością danych transakcyjnych oraz deterministycznym wykonaniem zleceń i strategii.

#### Kryteria Akceptacji Reliability
1.  WHEN system działa pod standardowym obciążeniem THEN system SHALL utrzymywać dostępność na poziomie **99.95%**.
2.  WHEN wystąpi awaria komponentu wykonawczego (np. `Rust Execution Engine`) THEN system SHALL automatycznie zastosować mechanizm `circuit breaker` i przejść w tryb `trading halt` dla dotkniętych instrumentów z powiadomieniem do systemu monitoringu i `Alertmanager`.
3.  WHEN wykryty zostanie `max_drawdown_guard` [1.5% dziennie lub 5% tygodniowo] THEN system SHALL wykonać `trading halt` dla wszystkich aktywnych strategii i wygenerować alert z powiadomieniem do operatora systemu.
4.  WHEN wykryty zostanie problem z jakością danych z giełdy (np. `data_staleness_seconds` > [5 gorącyh sekund] lub brakujące ticki) THEN system SHALL uruchomić procedurę `data_staleness_handling`, próbując przełączyć się na redundantne źródło danych lub zawiesić analizę i handel dla danego instrumentu.
5.  WHEN wystąpi przekroczenie limitów zapytań do API giełdy (`rate_limit_exhaustion`) THEN system SHALL zastosować zaplanowane przerwy i mechanizmy `retry` z wykładniczym opóźnieniem zgodnie z dokumentacją API giełdy dla danego endpointu.
6.  WHEN system zostanie zatrzymany lub zrestartowany (np. wdrożenie nowej wersji) THEN system SHALL zapewnić mechanizm `rollback procedure` pozwalający na powrót do poprzedniego stabilnego stanu wykonawczego, z minimalnym `CTIT` (critical time to interactive).
7.  WHEN system wykryje `clock skew` (różnicę czasu z serwerem giełdowym) przekraczającą [50 ms] THEN system SHALL podjąć próbę synchronizacji czasu (NTP) i uruchomić alert `clock_skew_alertheavy`.
8.  WHEN wystąpią `partial fills` lub duplikaty zleceń THEN system SHALL zastosować mechanizmy `idempotencyjności` kluczy i algorytmy deduplikacji w celu zapewnienia spójności stanu zleceń.
9.  WHEN konfigurowany jest `position sizing` THEN system SHALL uwzględniać parametry `risk_per_trade` [0.5%] i `exposure_limits` [max 10% kapitału na instrument] w celu zachowania stabilności portfela.
10. WHEN system działa w trybie `paper trading` lub `shadow trading` THEN musi on działać deterministycznie, symulować logikę produkcyjną z minimalnym odchyleniem w symulacji i zachować spójność stanu.
11. WHEN system jest włączony w celu `backtesting` THEN musi gwarantować odtwarzalność wyników przy tych samych danych wejściowych i stanie początkowym.
12. WHEN system napotka błędy jakości danych THEN system SHALL zastosować procedury walidacji danych i obsługi błędów z mechanizmami `retry`.
13. WHEN system zarządza zleceniami THEN musi modelować kolejność `FIFO` oraz obsługiwać `Time-In-Force` (GTC, IOC, FOK) zgodnie z dokumentacją giełdy, zapewniając atomowość operacji.
14. WHEN system jest uruchamiany THEN musi posiadać mechanizm `kill switch` umożliwiający natychmiastowe zatrzymanie wszelkich operacji handlowych.
15. WHEN system konfiguruje `max_daily_loss` [2.0% dziennie] THEN musi emitować alerty i wymuszać `trading halt` po jego osiągnięciu.
16. WHEN zlecenia są anulowane THEN musi być to proces atomowy z obsługą `cancel-on-disconnect`.
17. WHEN system obsługuje `maintenance windows` THEN musi posiadać `trading halt/resume` procedury dostosowane do ogłoszeń giełdowych.
18. WHEN system zarządza historią zleceń THEN musi zapewnić obsługę `pagination` i filtrowanie danych.
19. WHEN system mapuje symbole giełdowe THEN musi działać poprawnie pomimo różnic w nazewnictwie między giełdami.
20. WHEN system wykryje przekroczenie `max_daily_loss` THEN musi zarejestrować to zdarzenie i zablokować dalsze operacje do końca dnia.

### 3.2 Performance

System SMC Trading Agent musi przetwarzać dane i zlecenia z minimalnym opóźnieniem, zapewniając wysoką przepustowość i efektywne wykorzystanie zasobów.

#### Kryteria Akceptacji Performance
1.  WHEN system przetwarza dane rynkowe THEN główny potok przetwarzania musi osiągać P95 `latency` `< 50ms` dla pojedynczego ticka.
2.  WHEN system wykonuje zlecenie THEN budżet `latency` dla jego przesłania do giełdy musi wynosić P95 `< 100ms`.
3.  WHEN system oblicza `slippage` THEN musi być on w granicach maksymalnie `5 bps` dla zleceń market na głównych parach.
4.  WHEN system zarządza pozcjami THEN musi zapewniać aktualizację stanu pozycji w czasie rzeczywistym, z P95 `< 200ms` od momentu wpływu danych o transakcji.
5.  WHEN przeprowadzany jest `backtesting` THEN symulacja miliona transakcji musi zająć maksymalnie `10 minut` na wydzielonym środowisku testowym.
6.  WHEN system zarządza `position sizing` THEN obliczenia muszą być wykonywane w czasie P95 `< 30ms`.
7.  WHEN system wykryje `clock skew` THEN reakcja na różnicę czasu musi odbyć się w czasie P95 `< 10ms`.
8.  WHEN system obsługuje żądania API giełd THEN musi przestrzegać ich `rate-limits` z zastosowaniem opóźnień zgodnie z dokumentacją, utrzymując średnią liczbę żądań na sekundę w dopuszczalnych granicach.
9.  WHEN konfigurowane są limity zasobów GPU/CPU/pamięci w Kubernetes THEN muszą być one ustawione optymalnie, z `requests` < `limits` (np. CPU: `200m` < `500m`, Memory: `256Mi` < `768Mi`).
10. WHEN system implementuje `autoscaling` THEN musi reagować na wzrost obciążenia (`req/s` > 30%) w ciągu `5 minut`.
11. WHEN system obsługuje `maintenance windows` THEN musi przejść w tryb `trading halt` w ciągu `1 minuty` od powiadomienia giełdy.
12. WHEN system ładuje dane THEN musi pozwalać na ładowanie okresów danych np. [5 lat] w czasie poniżej [1 minuty] na analizę.
13. WHEN system obsługuje `pagination` THEN musi to robić z limitem latency na stronę `< 1s`.
14. WHEN system wykonuje `fuzz testing` THEN musi generować zmienność danych wejściowych `1000` losowych danych/sekundę.
15. WHEN system realizuje komunikację Python-Rust THEN musi osiągnąć `latency` P95 `< 15ms`.
16. WHEN system zarządza profilem `max_usage` THEN musi utrzymywać wykorzystanie pamięci na instancję poniżej `512Mi`.
17. WHEN system obsługuje `load testing` THEN musi być w stanie obsłużyć P95 `1000` transakcji/sekundę bez degradacji wydajności.
18. WHEN system realizuje `chaos testing` THEN musi być w stanie odzyskać pełną funkcjonalność w ciągu `3 minut` po symulowanej awarii.
19. WHEN system dokonuje profilowania THEN musi raportować średnie czasy wykonania kluczowych funkcji poniżej `10ms`.
20. WHEN system obsługuje `trading halt` THEN musi być to proces nie dłuższy niż `1 minuta` od momentu detekcji problemu.

### 3.3 Observability

System musi posiadać rozbudowane możliwości obserwacji, umożliwiające monitorowanie stanu, wydajności i przepływu danych w czasie rzeczywistym, z naciskiem na metryki operacyjne i biznesowe.

#### Kryteria Akceptacji Observability
1.  WHEN system generuje logi THEN wszystkie logi muszą być w formacie JSON, zawierać `trace_id`, `request_id`, poziom logu, timestamp, oraz treść komunikatu, zcentralizowane w jednej lokalizacji (stdout/pliki/system zbierania logów) z opcją wysyłki do `ELK/Loki`.
2.  WHEN system generuje metryki THEN muszą być one zbierane przez `Prometheus`, obejmując metryki techniczne (`CPU`, `memory`, `IO`, `network`) i biznesowe (`order_latency`, `slippage`, `win_rate`, `drawdown`, `PNL`), z rozdzielczością P95 zbierania metryk `< 10s`.
3.  WHEN system obsługuje `tracing` THEN musi implementować `OpenTelemetry` dla rozproszonego śledzenia żądań przez wszystkie komponenty, z korelacją `trace_id` do `X-Request-ID` giełd, udostępniając dane do `Grafana Tempo`.
4.  WHEN system uruchamia alerty THEN muszą być one skonfigurowane w `Alertmanager` na podstawie zdefiniowanych `SLO/SLA/SLI` (np. `service_availability_slo` > 99.95%), z powiązanymi playbookami dla incydentów operacyjnych.
5.  WHEN system jest wdrażany THEN musi udostępniać `Grafana Dashboard JSON` dla monitorowania kluczowych metryk i stanu systemu w czasie rzeczywistym.
6.  WHEN system napotka błąd (`error`) THEN musi go logować z pełnym `stack trace` i powiązanym `trace_id`, a `Sentry` lub podobny system musi agregować błędy z mapami źródłowymi.
7.  WHEN system wykryje `clock skew` THEN musi wygenerować alert P95 `< 50ms` różnicy czasu.
8.  WHEN system obsługuje `data staleness` THEN musi być w stanie wygenerować alert P95 `< 5s` od momentu wykrycia przekroczenia progu `data_staleness_seconds`.
9.  WHEN system zarządza `rate limits` THEN musi posiadać metryki śledzące ich użycie i alerty przy zbliżaniu się do limitów.
10. WHEN system wykonuje działania handlowe THEN musi logować wszystkie zlecenia (`sent`, `filled`, `cancelled`, `partial_fill`) wraz z czasami i parametrami.
11. WHEN system uruchamia `backtesting` THEN musi generować szczegółowe logi transakcyjne i podsumowania wyników.
12. WHEN system wykryje `partial fills` lub duplikaty THEN musi rejestrować te zdarzenia z informacjami identyfikującymi problemy.
13. WHEN system obsługuje `maintenance windows` THEN musi logować rozpoczęcie/zakończenie operacji i podjęte działania `halt/resume`.
14. WHEN system uruchamia `fuzz testing` THEN musi rejestrować generowane dane wejściowe i wyniki.
15. WHEN system stosuje `autoscaling` THEN musi logować zdarzenia związane ze skalowaniem i jego przyczynami.
16. WHEN system wykrywa `cloud detection` THEN musi logować wyniki wykrywania środowiska i jego konfiguracji.
17. WHEN system wykonuje komendy `Terraform`/`Helm` THEN musi logować ich przebieg i wyniki.
18. WHEN system obsługuje `transactional integrity` THEN musi logować kluczowe kroki transakcji i ich statusy.
19. WHEN operacje systemu wpływają na zasoby THEN musi to być odzwierciedlone w metrykach systemowych (CPU, MEMORY, IO).
20. WHEN system analizuje dane THEN musi logować proces ładowania, walidacji i potencjalnych błędów.

### 3.4 Usability

Interfejs użytkownika musi być responsywny, intuicyjny i zapewniać precyzyjną kontrolę nad parametrami handlowymi i operacyjnymi.

#### Kryteria Akceptacji Usability
1.  WHEN użytkownik uruchamia system THEN interfejs musi być responsywny, dostępny i gotowy do interakcji w ciągu [5 sekund] od załadowania aplikacji.
2.  WHEN użytkownik wchodzi w interakcję z interfejsem THEN wszystkie akcje (zmiana parametrów, uruchomienie/zatrzymanie tradingu) muszą być natychmiast odbite w interfejsie z jasnym wizualnym feedbackiem.
3.  WHEN użytkownik przegląda dane historyczne THEN interfejs musi pozwalać na filtrowanie i sortowanie danych w czasie odpowiedzi poniżej [2 sekund] dla typowych zapytań.
4.  WHEN system zawiera tryby handlu (`backtesting`, `paper`, `shadow`, `dry-run`) THEN musi istnieć jasna opcja wyboru i przełączania trybów, z wyraźnym oznaczeniem aktywnego trybu.
5.  WHEN system zarządza zleceniami THEN interfejs musi prezentować transparentne informacje o statusie każdego zlecenia (`pending`, `executed`, `cancelled`, `partial_fill`) w czasie rzeczywistym.
6.  WHEN system jest konfigurowany THEN wszystkie opcje muszą być jasno opisane i walidowane w locie z natychmiastowym feedbackiem.
7.  WHEN użytkownik zarządza ryzykiem THEN musi łatwo ustawiać `risk_per_trade`, `max_daily_loss`, `exposure_limits` i `kill switch`.
8.  WHEN system udostępnia `runbooki` THEN muszą być one łatwo dostępne i zrozumiałe, z możliwością uruchomienia komend gdzie to możliwe i operacyjnie uzasadnione.
9.  WHEN użytkownik przegląda `Grafana Dashboard` THEN musi być on zoptymalizowany pod kątem szybkiego dostępu do kluczowych metryk i łatwy w nawigacji.
10. WHEN system obsługuje `maintenance windows` THEN musi wyświetlać jasne powiadomienia o nadchodzących lub trwających pracach konserwacyjnych giełd.
11. WHEN system prezentuje dane o `clock skew` THEN musi to być zrozumiałe, wraz z informacją o podjętych działaniach synchronizacyjnych.
12. WHEN system obsługuje `data staleness` THEN musi jasno zaznaczać dane potencjalnie nieaktualne i informować o przyczynie.
13. WHEN użytkownik zarządza historią zleceń THEN musi móc łatwo filtrować i przeglądać zlecenia według różnych kryteriów.
14. WHEN uruchomiony jest `trading halt` THEN interfejs musi jednoznacznie sygnalizować ten stan i informować o przyczynie.
15. WHEN planowane jest wdrożenie nowego agenta/strategii THEN interfejs musi pozwalać na łatwe konfiguracje i możliwość `dry-run`.
16. WHEN użytkownik przegląda diagnostykę THEN musi mieć dostęp do czytelnych komunikatów o błędach i logów z kontekstem.
17. WHEN system generuje raporty THEN muszą być one łatwe do wyeksportowania (CSV, JSON) i zrozumienia.
18. WHEN użytkownik korzysta z systemu THEN musi mieć dostęp do klarownej dokumentacji API i instrukcji obsługi.
19. WHEN system używa `pagination` THEN musi zapewniać intuicyjny interfejs do nawigacji.
20. WHEN system zarządza agentami THEN musi pozwalać na łatwe monitorowanie ich stanu i wydajności.

### 3.5 Maintainability

Kod źródłowy i infrastruktura muszą być łatwe do zrozumienia, modyfikacji i rozszerzenia przez zespół techniczny.

#### Kryteria Akceptacji Maintainability
1.  WHEN rozwijany jest nowy moduł THEN kod musi być zgodny ze standardami (PEP 8 dla Python, idiomatic Rust, React patterns), używać `kebab-case` dla plików, bez `magic numbers/strings`.
2.  WHEN wprowadzana jest zmiana THEN musi być pokryta testami jednostkowymi/integracyjnymi z pokryciem kodu `>= 85%` dla modyfikowanych modułów.
3.  WHEN rozszerzana jest funkcjonalność THEN nowe moduły muszą być zgodne z architekturą C4 i patternami systemowymi (`systemPatterns.md`), stosując DRY.
4.  WHEN dokumentacja jest tworzona/aktualizowana THEN musi być obecna w kodzie (TSDoc/docstrings), README modułów, oraz plikach Memory Bank z datą ostatniej aktualizacji.
5.  WHEN wprowadzana jest zmiana w API THEN musi być wersjonowana (SemVer) i udokumentowana w `OpenAPI` lub `GraphQL Schema`.
6.  WHEN rozwijany jest nowy feature THEN musi być osobnym modułem z jasno zdefiniowanymi interfejsami.
7.  WHEN wprowadzane są decyzje architektoniczne THEN muszą być udokumentowane w ADR.
8.  WHEN system jest deployowany THEN proces musi być odtwarzalny przez `Dockerfile`, `Helm`, `Terraform`.
9.  WHEN moduły są budowane THEN muszą być hermetyczne (`hermetic build`) i posiadać generowany SBOM (`Syft`).
10. WHEN wprowadzane są nowe zależności THEN muszą być udokumentowane i przejść walidację jakości (np. `npm audit` bez skanów bezpieczeństwa).
11. WHEN modyfikowana jest konfiguracja THEN musi być łatwo zarządzana przez `ConfigMaps`/`Secrets` (placeholders) i pliki konfiguracyjne (`.env`, `config.yaml`).
12. WHEN refaktoryzowany jest kod THEN musi być poprzedzony testami regresji.
13. WHEN stosowane są mechanizmy `catch-all`/`default` THEN muszą być dobrze zdefiniowane i rejestrowane.
14. WHEN obsługiwane są tryby tradingowe THEN każdy tryb musi być łatwy do skonfigurowania i przełączenia.
15. WHEN wdrażana jest logika zarządzania zleceniami THEN musi ona być modularna i łatwa do integracji z różnymi API giełd.
16. WHEN modyfikowany jest schemat danych THEN musi być to łatwe, z zachowaniem jakości i semantyki danych.
17. WHEN system jest skalowany THEN musi to być realizowane przez dodawanie instancji bez modyfikacji logiki.
18. WHEN wdrażane są nowe `quality gates` THEN muszą być łatwe do konfiguracji w CI.
19. WHEN implementowany jest `chaos testing` THEN musi być możliwy do uruchomienia bez modyfikacji głównej logiki.
20. WHEN stosowane jest `retry` THEN logika musi być łatwa do konfiguracji i monitorowania.

### 3.5 Portability

System musi być zaprojektowany z myślą o potencjalnym uruchomieniu w różnych środowiskach operacyjnych i chmurowych.

#### Kryteria Akceptacji Portability
1.  WHEN aplikacja jest budowana THEN proces budowania (`Dockerfile`, `Helm`, `Terraform`) musi być niezależny od konkretnego OS (Linux x86_64, ARM64).
2.  WHEN używane są komendy CLI THEN muszą być zgodne z powszechnymi wersjami (`bash`, `PowerShell` – głównie Linux preferowany).
3.  WHEN zasoby są wdrażane w Kubernetes THEN konfiguracja musi być kompatybilna z różnymi dystrybucjami (EKS, GKE, AKS, K3s) za pomocą standardowych `resources`.
4.  WHEN używane są zmienne środowiskowe THEN ich nazewnictwo musi być standardowe, unikać specyficznych OS znaków.
5.  WHEN konfigurowana jest infrastruktura THEN `Terraform` musi pozwalać na wybór dostawcy chmury (AWS, GCP, Azure) bez zmiany głównej logiki konfiguracji.
6.  WHEN system używa baz danych THEN ich abstrakcja musi umożliwiać zmianę dostawcy (np. PostgreSQL na TimescaleDB) z minimalnymi modyfikacjami kodu.
7.  WHEN zarządzane są dane THEN formaty danych (JSON, CSV) muszą być standardowe i łatwe do odczytu w wielu środowiskach.
8.  WHEN system jest uruchamiany lokalnie THEN musi być możliwe przez `docker-compose` lub skrypty startowe z minimalną ręczną konfiguracją.
9.  WHEN system korzysta z zewnętrznych API THEN kontrakty API muszą być jasno udokumentowane dla łatwej integracji z innymi implementacjami.
10. WHEN metryki są zbierane THEN format musi być zgodny ze standardami Prometheus, umożliwiając integrację z różnymi systemami monitoringu.
11. WHEN system implementuje `OpenTelemetry` THEN musi być możliwe skonfigurowanie `collector` dla różnych back-endów telemetrycznych.
12. WHEN stosowane są `Quality Gates` THEN muszą być konfigurowalne dla różnych środowisk CI/CD.
13. WHEN system zarządza konfiguracją THEN musi pozwalać na łatwe przełączanie między środowiskami (`dev`, `stage`, `prod`) przez zmienne środowiskowe/pliki konfiguracyjne.
14. WHEN system używa `Helm` THEN musi być możliwa adaptacja przez `values.yaml` i `kustomization`.
15. WHEN system loguje informacje THEN format logów musi być ustandaryzowany (JSON) dla parsowania w różnych systemach.
16. WHEN system obsługuje `trading halt/resume` THEN musi to być mechanizm niezależny od platformy deploymentu.
17. WHEN system zarządza zleceniami THEN logika musi być oddzielona od specyfiki giełd, umożliwiając łatwe dodawanie nowych integracji.
18. WHEN system zarządza danymi THEN musi używać standardowych formatów i łatwych do parsowania schematów.
19. WHEN system implementuje `autoscaling` THEN musi opierać się na standardowych mechanizmach orkiestracji (Kubernetes HPA).
20. WHEN system zawiera `runbooki` THEN muszą być one zrozumiałe dla ekspertów z różnych środowisk technicznych.

### 3.7 Scalability

System musi być zdolny do obsługi rosnącego obciążenia poprzez proporcjonalne zwiększanie zasobów.

#### Kryteria Akceptacji Scalability
1.  WHEN obciążenie systemu wzrośnie o 100% THEN system SHALL skalować się horyzontalnie, dodając instancje komponentów, przy utrzymaniu latency kluczowych operacji (np. `order_latency_p95`) poniżej `150ms`.
2.  WHEN użycie CPU na instancji backendu osiągnie [80%] THEN system SHALL automatycznie zwiększyć liczbę instancji backendu o [1] zgodnie z konfiguracją `HPA` w Kubernetes w ciągu [5 minut].
3.  WHEN system przetwarza > 1000 zleceń/sekundę THEN musi utrzymać `slippage` poniżej `7 bps` oraz `order_latency_p95` poniżej `120ms`.
4.  WHEN system zarządza danymi z [10+] giełd THEN musi skalować zdolność ich przetwarzania bez degradacji wydajności, z P95 `< 200ms` od momentu wpływu danych.
5.  WHEN system używa baz danych THEN musi pozwalać na ich skalowanie (replikacja, sharding) bez modyfikacji kluczowej logiki aplikacji.
6.  WHEN system obsługuje `maintenance windows` THEN musi przejść w tryb `HALTED` dla wszystkich operacji w ciągu `1 minuty` i wznowić prace w ciągu `2 minut`.
7.  WHEN system zarządza `capacity planning` THEN musi pozwalać na estymację potrzebnych zasobów z dokładnością do [20%].
8.  WHEN system napotka `rate_limit` giełdy THEN musi zastosować mechanizmy `backoff` i `retry` z wykładniczym opóźnieniem.
9.  WHEN system stosuje `autoscaling` THEN musi reagować na wzrost metryk obciążenia (np. `req/s` > 30%) w ciągu [3 minut].
10. WHEN system jest uruchamiany w różnych środowiskach THEN konfiguracja musi umożliwiać łatwe dostosowanie zasobów (`requests`/`limits` w Kubernetes).
11. WHEN system przetwarza dane historyczne THEN musi być w stanie analizować do [5 lat] danych w akceptowalnym czasie.
12. WHEN system stosuje `fuzz testing` THEN musi symulować obciążenia generujące od [1000] do [10000] losowych danych na sekundę.
13. WHEN system zarządza [1000+] pozycjami THEN musi efektywnie zarządzać `position sizing`.
14. WHEN system stosuje `chaos testing` THEN musi symulować awarie [5+] usług i zachować ograniczoną funkcjonalność.
15. WHEN system analizuje `OHLCV` THEN musi to robić z dokładnością do ticka, nie powodując opóźnień w przetwarzaniu bieżących transakcji.
16. WHEN system zapisuje dane THEN musi to robić z mechanizmami zapewniającymi integralność danych niezależnie od ich skali.
17. WHEN system zarządza wieloma strategiami THEN musi izolować zasoby obliczeniowe i logiczne każdej z nich.
18. WHEN system obsługuje `trading halt` THEN musi działać szybko i nie wpływać ujemnie na inne, nadal działające komponenty.
19. WHEN system konfigurowany jest pod kątem `max_daily_loss` THEN musi to być łatwo konfigurowalne dla wielu instancji agentów handlowych z indywidualnymi limitami.
20. WHEN system monitoruje `slippage` THEN musi robić to dla każdego instrumentu i transakcji, agregując dane w czasie rzeczywistym.

### 3.5 Maintainability *(Powielone kryteria z Wymagania 2 dla zachowania struktury)*

Kod źródłowy i infrastruktura muszą być łatwe do zrozumienia, modyfikacji i rozszerzenia przez zespół techniczny.

#### Kryteria Akceptacji Maintainability
1.  WHEN rozwijany jest nowy moduł THEN kod musi być zgodny ze standardami kodowania (PEP 8 dla Python, idiomatic Rust, React patterns) i konwencjami nazewnictwa (`kebab-case`), bez `magic numbers/strings`.
2.  WHEN wprowadzana jest zmiana THEN musi być pokryta testami jednostkowymi i integracyjnymi z pokryciem kodu `>= 85%` dla modyfikowanych modułów.
3.  WHEN rozszerzana jest funkcjonalność THEN nowe moduły muszą być zgodne z architekturą C4 i patternami systemowymi (`systemPatterns.md`), stosując DRY.
4.  WHEN dokumentacja jest tworzona/aktualizowana THEN musi być obecna w kodzie (TSDoc/docstrings), jako README w modułach, oraz w plikach Memory Bank z datą ostatniej aktualizacji.
5.  WHEN wprowadzana jest zmiana w API THEN musi być wersjonowana (SemVer) i udokumentowana w `OpenAPI` lub `GraphQL Schema`.
6.  WHEN rozwijany jest nowy feature THEN musi być osobnym modułem z jasno zdefiniowanymi interfejsami.
7.  WHEN wprowadzane są decyzje architektoniczne THEN muszą być udokumentowane w ADR.
8.  WHEN system jest deployowany THEN proces musi być odtwarzalny przez `Dockerfile`, `Helm`, `Terraform`.
9.  WHEN moduły są budowane THEN muszą być hermetyczne (`hermetic build`) i posiadać generowany SBOM (`Syft`).
10. WHEN wprowadzane są nowe zależności THEN muszą być udokumentowane i przejść walidację jakości (np. `npm audit` bez skanów bezpieczeństwa).
11. WHEN modyfikowana jest konfiguracja THEN musi być łatwo zarządzana przez `ConfigMaps`/`Secrets` (placeholders) i pliki konfiguracyjne (`.env`, `config.yaml`).
12. WHEN refaktoryzowany jest kod THEN musi być poprzedzony testami regresji.
13. WHEN stosowane są mechanizmy `catch-all`/`default` THEN muszą być dobrze zdefiniowane i rejestrowane.
14. WHEN obsługiwane są tryby tradingowe THEN każdy tryb musi być łatwy do skonfigurowania i przełączenia.
15. WHEN wdrażana jest logika zarządzania zleceniami THEN musi ona być modularna i łatwa do integracji z różnymi API giełd.
16. WHEN modyfikowany jest schemat danych THEN musi być to łatwe, z zachowaniem jakości i semantyki danych.
17. WHEN system jest skalowany THEN musi to być realizowane przez dodawanie instancji bez modyfikacji logiki.
18. WHEN wdrażane są nowe `quality gates` THEN muszą być łatwe do konfiguracji w CI.
19. WHEN implementowany jest `chaos testing` THEN musi być możliwy do uruchomienia bez modyfikacji głównej logiki.
20. WHEN stosowane jest `retry` THEN logika musi być łatwa do konfiguracji i monitorowania.

### 3.5 Portability

System jest zaprojektowany z myślą o potencjalnym uruchomieniu w różnych środowiskach operacyjnych i chmurowych.

#### Kryteria Akceptacji Portability
1.  WHEN aplikacja jest budowana THEN proces budowania (`Dockerfile`, `Helm`, `Terraform`) musi być niezależny od konkretnego OS (Linux x86_64, ARM64).
2.  WHEN używane są komendy CLI THEN muszą być zgodne z powszechnymi wersjami (`bash`, `PowerShell` – głównie Linux preferowany).
3.  WHEN zasoby są wdrażane w Kubernetes THEN konfiguracja musi być kompatybilna z różnymi dystrybucjami (EKS, GKE, AKS, K3s) za pomocą standardowych `resources`.
4.  WHEN używane są zmienne środowiskowe THEN ich nazewnictwo musi być standardowe, unikać specyficznych OS znaków.
5.  WHEN konfigurowana jest infrastruktura THEN `Terraform` musi pozwalać na wybór dostawcy chmury (AWS, GCP, Azure) bez zmiany głównej logiki konfiguracji.
6.  WHEN system używa baz danych THEN ich abstrakcja musi umożliwiać zmianę dostawcy (np. PostgreSQL na TimescaleDB) z minimalnymi modyfikacjami kodu.
7.  WHEN zarządzane są dane THEN formaty danych (JSON, CSV) muszą być standardowe i łatwe do odczytu w wielu środowiskach.
8.  WHEN system jest uruchamiany lokalnie THEN musi być możliwe przez `docker-compose` lub skrypty startowe z minimalną ręczną konfiguracją.
9.  WHEN system korzysta z zewnętrznych API THEN kontrakty API muszą być jasno udokumentowane dla łatwej integracji z innymi implementacjami.
10. WHEN metryki są zbierane THEN format musi być zgodny ze standardami Prometheus, umożliwiając integrację z różnymi systemami monitoringu.
11. WHEN system implementuje `OpenTelemetry` THEN musi być możliwe skonfigurowanie `collector` dla różnych back-endów telemetrycznych.
12. WHEN stosowane są `Quality Gates` THEN muszą być konfigurowalne dla różnych środowisk CI/CD.
13. WHEN system zarządza konfiguracją THEN musi pozwalać na łatwe przełączanie między środowiskami (`dev`, `stage`, `prod`) przez zmienne środowiskowe/pliki konfiguracyjne.
14. WHEN system używa `Helm` THEN musi być możliwa adaptacja przez `values.yaml` i `kustomization`.
15. WHEN system loguje informacje THEN format logów musi być ustandaryzowany (JSON) dla parsowania w różnych systemach.
16. WHEN system obsługuje `trading halt/resume` THEN musi to być mechanizm niezależny od platformy deploymentu.
17. WHEN system zarządza zleceniami THEN logika musi być oddzielona od specyfiki giełd, umożliwiając łatwe dodawanie nowych integracji.
18. WHEN system zarządza danymi THEN musi używać standardowych formatów i łatwych do parsowania schematów.
19. WHEN system implementuje `autoscaling` THEN musi opierać się na standardowych mechanizmach orkiestracji (Kubernetes HPA).
20. WHEN system zawiera `runbooki` THEN muszą być one zrozumiałe dla ekspertów z różnych środowisk technicznych.

### 3.7 Scalability

System musi być zdolny do obsługi rosnącego obciążenia poprzez proporcjonalne zwiększanie zasobów.

#### Kryteria Akceptacji Scalability
1.  WHEN obciążenie systemu wzrośnie o 100% THEN system SHALL skalować się horyzontalnie, dodając instancje komponentów, przy utrzymaniu `latency` kluczowych operacji (np. `order_latency_p95`) poniżej `150ms`.
2.  WHEN użycie CPU na instancji backendu osiągnie [80%] THEN system SHALL automatycznie zwiększyć liczbę instancji backendu o [1] zgodnie z konfiguracją `HPA` w Kubernetes w ciągu [5 minut].
3.  WHEN system przetwarza > 1000 zleceń/sekundę THEN musi utrzymać `slippage` poniżej `7 bps` oraz `order_latency_p95` poniżej `120ms`.
4.  WHEN system zarządza danymi z [10+] giełd THEN musi skalować zdolność ich przetwarzania bez degradacji wydajności, z P95 `< 200ms` od momentu wpływu danych.
5.  WHEN system używa baz danych THEN musi pozwalać na ich skalowanie (replikacja, sharding) bez modyfikacji kluczowej logiki aplikacji.
6.  WHEN system obsługuje `maintenance windows` THEN musi przejść w tryb `HALTED` dla wszystkich operacji w ciągu `1 minuty` i wznowić prace w ciągu `2 minut`.
7.  WHEN system zarządza `capacity planning` THEN musi pozwalać na estymację potrzebnych zasobów z dokładnością do [20%].
8.  WHEN system napotka `rate_limit` giełdy THEN musi zastosować mechanizmy `backoff` i `retry` z wykładniczym opóźnieniem.
9.  WHEN system stosuje `autoscaling` THEN musi reagować na wzrost metryk obciążenia (np. `req/s` > 30%) w ciągu [3 minut].
10. WHEN system jest uruchamiany w różnych środowiskach THEN konfiguracja musi umożliwiać łatwe dostosowanie zasobów (`requests`/`limits` w Kubernetes).
11. WHEN system przetwarza dane historyczne THEN musi być w stanie analizować do [5 lat] danych w akceptowalnym czasie.
12. WHEN system stosuje `fuzz testing` THEN musi symulować obciążenia generujące od [1000] do [10000] losowych danych na sekundę.
13. WHEN system zarządza [1000+] pozycjami THEN musi efektywnie zarządzać `position sizing`.
14. WHEN system stosuje `chaos testing` THEN musi symulować awarie [5+] usług i zachować ograniczoną funkcjonalność.
15. WHEN system analizuje `OHLCV` THEN musi to robić z dokładnością do ticka, nie powodując opóźnień w przetwarzaniu bieżących transakcji.
16. WHEN system zapisuje dane THEN musi to robić z mechanizmami zapewniającymi integralność danych niezależnie od ich skali.
17. WHEN system zarządza wieloma strategiami THEN musi izolować zasoby obliczeniowe i logiczne każdej z nich.
18. WHEN system obsługuje `trading halt` THEN musi działać szybko i nie wpływać ujemnie na inne, nadal działające komponenty.
19. WHEN system konfigurowany jest pod kątem `max_daily_loss` THEN musi to być łatwo konfigurowalne dla wielu instancji agentów handlowych z indywidualnymi limitami.
20. WHEN system monitoruje `slippage` THEN musi robić to dla każdego instrumentu i transakcji, agregując dane w czasie rzeczywistym.

### 3.5 Maintainability *(Powielone kryteria z Wymagania 2 ze względu na konieczność zapewnienia szczegółowości)*

Kod źródłowy i infrastruktura muszą być łatwe do zrozumienia, modyfikacji i rozszerzenia przez zespół techniczny.

#### Kryteria Akceptacji Maintainability
1.  WHEN rozwijany jest nowy moduł THEN kod musi być zgodny ze standardami kodowania (PEP 8 dla Python, idiomatic Rust, React patterns) i konwencjami nazewnictwa (`kebab-case`), bez `magic numbers/strings`.
2.  WHEN wprowadzana jest zmiana THEN musi być pokryta testami jednostkowymi i integracyjnymi z pokryciem kodu `>= 85%` dla modyfikowanych modułów.
3.  WHEN rozszerzana jest funkcjonalność THEN nowe moduły muszą być zgodne z architekturą C4 i patternami systemowymi (`systemPatterns.md`), stosując DRY.
4.  WHEN dokumentacja jest tworzona/aktualizowana THEN musi być obecna w kodzie (TSDoc/docstrings), jako README w modułach, oraz w plikach Memory Bank z datą ostatniej aktualizacji.
5.  WHEN wprowadzana jest zmiana w API THEN musi być wersjonowana (SemVer) i udokumentowana w `OpenAPI` lub `GraphQL Schema`.
6.  WHEN rozwijany jest nowy feature THEN musi być osobnym modułem z jasno zdefiniowanymi interfejsami.
7.  WHEN wprowadzane są decyzje architektoniczne THEN muszą być udokumentowane w ADR.
8.  WHEN system jest deployowany THEN proces musi być odtwarzalny przez `Dockerfile`, `Helm`, `Terraform`.
9.  WHEN moduły są budowane THEN muszą być hermetyczne (`hermetic build`) i posiadać generowany SBOM (`Syft`).
10. WHEN wprowadzane są nowe zależności THEN muszą być udokumentowane i przejść walidację jakości (np. `npm audit` bez skanów bezpieczeństwa).
11. WHEN modyfikowana jest konfiguracja THEN musi być łatwo zarządzana przez `ConfigMaps`/`Secrets` (placeholders) i pliki konfiguracyjne (`.env`, `config.yaml`).
12. WHEN refaktoryzowany jest kod THEN musi być poprzedzony testami regresji.
13. WHEN stosowane są mechanizmy `catch-all`/`default` THEN muszą być dobrze zdefiniowane i rejestrowane.
14. WHEN obsługiwane są tryby tradingowe THEN każdy tryb musi być łatwy do skonfigurowania i przełączenia.
15. WHEN wdrażana jest logika zarządzania zleceniami THEN musi ona być modularna i łatwa do integracji z różnymi API giełd.
16. WHEN modyfikowany jest schemat danych THEN musi być to łatwe, z zachowaniem jakości i semantyki danych.
17. WHEN system jest skalowany THEN musi to być realizowane przez dodawanie instancji bez modyfikacji logiki.
18. WHEN wdrażane są nowe `quality gates` THEN muszą być łatwe do konfiguracji w CI.
19. WHEN implementowany jest `chaos testing` THEN musi być możliwy do uruchomienia bez modyfikacji głównej logiki.
20. WHEN stosowane jest `retry` THEN logika musi być łatwa do konfiguracji i monitorowania.

### 3.5 Portability

System musi być zaprojektowany z myślą o potencjalnym uruchomieniu w różnych środowiskach operacyjnych i chmurowych.

#### Kryteria Akceptacji Portability
1.  WHEN aplikacja jest budowana THEN proces budowania (`Dockerfile`, `Helm`, `Terraform`) musi być niezależny od konkretnego OS (Linux x86_64, ARM64).
2.  WHEN używane są komendy CLI THEN muszą być zgodne z powszechnymi wersjami (`bash`, `PowerShell` – głównie Linux preferowany).
3.  WHEN zasoby są wdrażane w Kubernetes THEN konfiguracja musi być kompatybilna z różnymi dystrybucjami (EKS, GKE, AKS, K3s) za pomocą standardowych `resources`.
4.  WHEN używane są zmienne środowiskowe THEN ich nazewnictwo musi być standardowe, unikać specyficznych OS znaków.
5.  WHEN konfigurowana jest infrastruktura THEN `Terraform` musi pozwalać na wybór dostawcy chmury (AWS, GCP, Azure) bez zmiany głównej logiki konfiguracji.
6.  WHEN system używa baz danych THEN ich abstrakcja musi umożliwiać zmianę dostawcy (np. PostgreSQL na TimescaleDB) z minimalnymi modyfikacjami kodu.
7.  WHEN zarządzane są dane THEN formaty danych (JSON, CSV) muszą być standardowe i łatwe do odczytu w wielu środowiskach.
8.  WHEN system jest uruchamiany lokalnie THEN musi być możliwe przez `docker-compose` lub skrypty startowe z minimalną ręczną konfiguracją.
9.  WHEN system korzysta z zewnętrznych API THEN kontrakty API muszą być jasno udokumentowane dla łatwej integracji z innymi implementacjami.
10. WHEN metryki są zbierane THEN format musi być zgodny ze standardami Prometheus, umożliwiając integrację z różnymi systemami monitoringu.
11. WHEN system implementuje `OpenTelemetry` THEN musi być możliwe skonfigurowanie `collector` dla różnych back-endów telemetrycznych.
12. WHEN stosowane są `Quality Gates` THEN muszą być konfigurowalne dla różnych środowisk CI/CD.
13. WHEN system zarządza konfiguracją THEN musi pozwalać na łatwe przełączanie między środowiskami (`dev`, `stage`, `prod`) przez zmienne środowiskowe/pliki konfiguracyjne.
14. WHEN system używa `Helm` THEN musi być możliwa adaptacja przez `values.yaml` i `kustomization`.
15. WHEN system loguje informacje THEN format logów musi być ustandaryzowany (JSON) dla parsowania w różnych systemach.
16. WHEN system obsługuje `trading halt/resume` THEN musi to być mechanizm niezależny od platformy deploymentu.
17. WHEN system zarządza zleceniami THEN logika musi być oddzielona od specyfiki giełd, umożliwiając łatwe dodawanie nowych integracji.
18. WHEN system zarządza danymi THEN musi używać standardowych formatów i łatwych do parsowania schematów.
19. WHEN system implementuje `autoscaling` THEN musi opierać się na standardowych mechanizmach orkiestracji (Kubernetes HPA).
20. WHEN system zawiera `runbooki` THEN muszą być one zrozumiałe dla ekspertów z różnych środowisk technicznych.

### 3.7 Scalability

System musi być zdolny do obsługi rosnącego obciążenia poprzez proporcjonalne zwiększanie zasobów.

#### Kryteria Akceptacji Scalability
1.  WHEN obciążenie systemu wzrośnie o 100% THEN system SHALL skalować się horyzontalnie, dodając instancje komponentów, przy utrzymaniu `latency` kluczowych operacji (np. `order_latency_p95`) poniżej `150ms`.
2.  WHEN użycie CPU na instancji backendu osiągnie [80%] THEN system SHALL automatycznie zwiększyć liczbę instancji backendu o [1] zgodnie z konfiguracją `HPA` w Kubernetes w ciągu [5 minut].
3.  WHEN system przetwarza > 1000 zleceń/sekundę THEN musi utrzymać `slippage` poniżej `7 bps` oraz `order_latency_p95` poniżej `120ms`.
4.  WHEN system zarządza danymi z [10+] giełd THEN musi skalować zdolność ich przetwarzania bez degradacji wydajności, z P95 `< 200ms` od momentu wpływu danych.
5.  WHEN system używa baz danych THEN musi pozwalać na ich skalowanie (replikacja, sharding) bez modyfikacji kluczowej logiki aplikacji.
6.  WHEN system obsługuje `maintenance windows` THEN musi przejść w tryb `HALTED` dla wszystkich operacji w ciągu `1 minuty` i wznowić prace w ciągu `2 minut`.
7.  WHEN system zarządza `capacity planning` THEN musi pozwalać na estymację potrzebnych zasobów z dokładnością do [20%].
8.  WHEN system napotka `rate_limit` giełdy THEN musi zastosować mechanizmy `backoff` i `retry` z wykładniczym opóźnieniem.
9.  WHEN system stosuje `autoscaling` THEN musi reagować na wzrost metryk obciążenia (np. `req/s` > 30%) w ciągu [3 minut].
10. WHEN system jest uruchamiany w różnych środowiskach THEN konfiguracja musi umożliwiać łatwe dostosowanie zasobów (`requests`/`limits` w Kubernetes).
11. WHEN system przetwarza dane historyczne THEN musi być w stanie analizować do [5 lat] danych w akceptowalnym czasie.
12. WHEN system stosuje `fuzz testing` THEN musi symulować obciążenia generujące od [1000] do [10000] losowych danych na sekundę.
13. WHEN system zarządza [1000+] pozycjami THEN musi efektywnie zarządzać `position sizing`.
14. WHEN system stosuje `chaos testing` THEN musi symulować awarie [5+] usług i zachować ograniczoną funkcjonalność.
15. WHEN system analizuje `OHLCV` THEN musi to robić z dokładnością do ticka, nie powodując opózeń w przetwarzaniu bieżących transakcji.
16. WHEN system zapisuje dane THEN musi to robić z mechanizmami zapewniającymi integralność danych niezależnie od ich skali.
17. WHEN system zarządza wieloma strategiami THEN musi izolować zasoby obliczeniowe i logiczne każdej z nich.
18. WHEN system obsługuje `trading halt` THEN musi działać szybko i nie wpływać ujemnie na inne, nadal działające komponenty.
19. WHEN system konfigurowany jest pod kątem `max_daily_loss` THEN musi to być łatwo konfigurowalne dla wielu instancji agentów handlowych z indywidualnymi limitami.
20. WHEN system monitoruje `slippage` THEN musi robić to dla każdego instrumentu i transakcji, agregując dane w czasie rzeczywistym.

### 3.5 Maintainability *(Powielone kryteria z Wymagania 2 ze względu na konieczność zapewnienia szczegółowości)*

Kod źródłowy i infrastruktura muszą być łatwe do zrozumienia, modyfikacji i rozszerzenia przez zespół techniczny.

#### Kryteria Akceptacji Maintainability
1.  WHEN rozwijany jest nowy moduł THEN kod musi być zgodny ze standardami kodowania (PEP 8 dla Python, idiomatic Rust, React patterns) i konwencjami nazewnictwa (`kebab-case`), bez `magic numbers/strings`.
2.  WHEN wprowadzana jest zmiana THEN musi być pokryta testami jednostkowymi i integracyjnymi z pokryciem kodu `>= 85%` dla modyfikowanych modułów.
3.  WHEN rozszerzana jest funkcjonalność THEN nowe moduły muszą być zgodne z architekturą C4 i patternami systemowymi (`systemPatterns.md`), stosując DRY.
4.  WHEN dokumentacja jest tworzona/aktualizowana THEN musi być obecna w kodzie (TSDoc/docstrings), jako README w modułach, oraz w plikach Memory Bank z datą ostatniej aktualizacji.
5.  WHEN wprowadzana jest zmiana w API THEN musi być wersjonowana (SemVer) i udokumentowana w `OpenAPI` lub `GraphQL Schema`.
6.  WHEN rozwijany jest nowy feature THEN musi być osobnym modułem z jasno zdefiniowanymi interfejsami.
7.  WHEN wprowadzane są decyzje architektoniczne THEN muszą być udokumentowane w ADR.
8.  WHEN system jest deployowany THEN proces musi być odtwarzalny przez `Dockerfile`, `Helm`, `Terraform`.
9.  WHEN moduły są budowane THEN muszą być hermetyczne (`hermetic build`) i posiadać generowany SBOM (`Syft`).
10. WHEN wprowadzane są nowe zależności THEN muszą być udokumentowane i przejść walidację jakości (np. `npm audit` bez skanów bezpieczeństwa).
11. WHEN modyfikowana jest konfiguracja THEN musi być łatwo zarządzana przez `ConfigMaps`/`Secrets` (placeholders) i pliki konfiguracyjne (`.env`, `config.yaml`).
12. WHEN refaktoryzowany jest kod THEN musi być poprzedzony testami regresji.
13. WHEN stosowane są mechanizmy `catch-all`/`default` THEN muszą być dobrze zdefiniowane i rejestrowane.
14. WHEN obsługiwane są tryby tradingowe THEN każdy tryb musi być łatwy do skonfigurowania i przełączenia.
15. WHEN wdrażana jest logika zarządzania zleceniami THEN musi ona być modularna i łatwa do integracji z różnymi API giełd.
16. WHEN modyfikowany jest schemat danych THEN musi być to łatwe, z zachowaniem jakości i semantyki danych.
17. WHEN system jest skalowany THEN musi to być realizowane przez dodawanie instancji bez modyfikacji logiki.
18. WHEN wdrażane są nowe `quality gates` THEN muszą być łatwe do konfiguracji w CI.
19. WHEN implementowany jest `chaos testing` THEN musi być możliwy do uruchomienia bez modyfikacji głównej logiki.
20. WHEN stosowane jest `retry` THEN logika musi być łatwa do konfiguracji i monitorowania.

### 3.5 Portability

System musi być zaprojektowany z myślą o potencjalnym uruchomieniu w różnych środowiskach operacyjnych i chmurowych.

#### Kryteria Akceptacji Portability
1.  WHEN aplikacja jest budowana THEN proces budowania (`Dockerfile`, `Helm`, `Terraform`) musi być niezależny od konkretnego OS (Linux x86_64, ARM64).
2.  WHEN używane są komendy CLI THEN muszą być zgodne z powszechnymi wersjami (`bash`, `PowerShell` – głównie Linux preferowany).
3.  WHEN zasoby są wdrażane w Kubernetes THEN konfiguracja musi być kompatybilna z różnymi dystrybucjami (EKS, GKE, AKS, K3s) za pomocą standardowych `resources`.
4.  WHEN używane są zmienne środowiskowe THEN ich nazewnictwo musi być standardowe, unikać specyficznych OS znaków.
5.  WHEN konfigurowana jest infrastruktura THEN `Terraform` musi pozwalać na wybór dostawcy chmury (AWS, GCP, Azure) bez zmiany głównej logiki konfiguracji.
6.  WHEN system używa baz danych THEN ich abstrakcja musi umożliwiać zmianę dostawcy (np. PostgreSQL na TimescaleDB) z minimalnymi modyfikacjami kodu.
7.  WHEN zarządzane są dane THEN formaty danych (JSON, CSV) muszą być standardowe i łatwe do odczytu w wielu środowiskach.
8.  WHEN system jest uruchamiany lokalnie THEN musi być możliwe przez `docker-compose` lub skrypty startowe z minimalną ręczną konfiguracją.
9.  WHEN system korzysta z zewnętrznych API THEN kontrakty API muszą być jasno udokumentowane dla łatwej integracji z innymi implementacjami.
10. WHEN metryki są zbierane THEN format musi być zgodny ze standardami Prometheus, umożliwiając integrację z różnymi systemami monitoringu.
11. WHEN system implementuje `OpenTelemetry` THEN musi być możliwe skonfigurowanie `collector` dla różnych back-endów telemetrycznych.
12. WHEN stosowane są `Quality Gates` THEN muszą być konfigurowalne dla różnych środowisk CI/CD.
13. WHEN system zarządza konfiguracją THEN musi pozwalać na łatwe przełączanie między środowiskami (`dev`, `stage`, `prod`) przez zmienne środowiskowe/pliki konfiguracyjne.
14. WHEN system używa `Helm` THEN musi być możliwa adaptacja przez `values.yaml` i `kustomization`.
15. WHEN system loguje informacje THEN format logów musi być ustandaryzowany (JSON) dla parsowania w różnych systemach.
16. WHEN system obsługuje `trading halt/resume` THEN musi to być mechanizm niezależny od platformy deploymentu.
17. WHEN system zarządza zleceniami THEN logika musi być oddzielona od specyfiki giełd, umożliwiając łatwe dodawanie nowych integracji.
18. WHEN system zarządza danymi THEN musi używać standardowych formatów i łatwych do parsowania schematów.
19. WHEN system implementuje `autoscaling` THEN musi opierać się na standardowych mechanizmach orkiestracji (Kubernetes HPA).
20. WHEN system zawiera `runbooki` THEN muszą być one zrozumiałe dla ekspertów z różnych środowisk technicznych.

### 3.7 Scalability

System musi być zdolny do obsługi rosnącego obciążenia poprzez proporcjonalne zwiększanie zasobów.

#### Kryteria Akceptacji Scalability
1.  WHEN obciążenie systemu wzrośnie o 100% THEN system SHALL skalować się horyzontalnie, dodając instancje komponentów, przy utrzymaniu `latency` kluczowych operacji (np. `order_latency_p95`) poniżej `150ms`.
2.  WHEN użycie CPU na instancji backendu osiągnie [80%] THEN system SHALL automatycznie zwiększyć liczbę instancji backendu o [1] zgodnie z konfiguracją `HPA` w Kubernetes w ciągu [5 minut].
3.  WHEN system przetwarza > 1000 zleceń/sekundę THEN musi utrzymać `slippage` poniżej `7 bps` oraz `order_latency_p95` poniżej `120ms`.
4.  WHEN system zarządza danymi z [10+] giełd THEN musi skalować zdolność ich przetwarzania bez degradacji wydajności, z P95 `< 200ms` od momentu wpływu danych.
5.  WHEN system używa baz danych THEN musi pozwalać na ich skalowanie (replikacja, sharding) bez modyfikacji kluczowej logiki aplikacji.
6.  WHEN system obsługuje `maintenance windows` THEN musi przejść w tryb `HALTED` dla wszystkich operacji w ciągu `1 minuty` i wznowić prace w ciągu `2 minut`.
7.  WHEN system zarządza `capacity planning` THEN musi pozwalać na estymację potrzebnych zasobów z dokładnością do [20%].
8.  WHEN system napotka `rate_limit` giełdy THEN musi zastosować mechanizmy `backoff` i `retry` z wykładniczym opóźnieniem.
9.  WHEN system stosuje `autoscaling` THEN musi reagować na wzrost metryk obciążenia (np. `req/s` > 30%) w ciągu [3 minut].
10. WHEN system jest uruchamiany w różnych środowiskach THEN konfiguracja musi umożliwiać łatwe dostosowanie zasobów (`requests`/`limits` w Kubernetes).
11. WHEN system przetwarza dane historyczne THEN musi być w stanie analizować do [5 lat] danych w akceptowalnym czasie.
12. WHEN system stosuje `fuzz testing` THEN musi symulować obciążenia generujące od [1000] do [10000] losowych danych na sekundę.
13. WHEN system zarządza [1000+] pozycjami THEN musi efektywnie zarządzać `position sizing`.
14. WHEN system stosuje `chaos testing` THEN musi symulować awarie [5+] usług i zachować ograniczoną funkcjonalność.
15. WHEN system analizuje `OHLCV` THEN musi to robić z dokładnością do ticka, nie powodując opóźnień w przetwarzaniu bieżących transakcji.
16. WHEN system zapisuje dane THEN musi to robić z mechanizmami zapewniającymi integralność danych niezależnie od ich skali.
17. WHEN system zarządza wieloma strategiami THEN musi izolować zasoby obliczeniowe i logiczne każdej z nich.
18. WHEN system obsługuje `trading halt` THEN musi działać szybko i nie wpływać ujemnie na inne, nadal działające komponenty.
19. WHEN system konfigurowany jest pod kątem `max_daily_loss` THEN musi to być łatwo konfigurowalne dla wielu instancji agentów handlowych z indywidualnymi limitami.
20. WHEN system monitoruje `slippage` THEN musi robić to dla każdego instrumentu i transakcji, agregując dane w czasie rzeczywistym.

### 3.5 Maintainability *(Powielone dla pełności, zgodne z oryginałem)*

Kod źródłowy i infrastruktura muszą być łatwe do zrozumienia, modyfikacji i rozszerzenia przez zespół techniczny.

#### Kryteria Akceptacji Maintainability
1.  WHEN rozwijany jest nowy moduł THEN kod musi być zgodny ze standardami kodowania (PEP 8 dla Python, idiomatic Rust, React patterns) i konwencjami nazewnictwa (`kebab-case`), bez `magic numbers/strings`.
2.  WHEN wprowadzana jest zmiana THEN musi być pokryta testami jednostkowymi i integracyjnymi z pokryciem kodu `>= 85%` dla modyfikowanych modułów.
3.  WHEN rozszerzana jest funkcjonalność THEN nowe moduły muszą być zgodne z architekturą C4 i patternami systemowymi (`systemPatterns.md`), stosując DRY.
4.  WHEN dokumentacja jest tworzona/aktualizowana THEN musi być obecna w kodzie (TSDoc/docstrings), jako README w modułach, oraz w plikach Memory Bank z datą ostatniej aktualizacji.
5.  WHEN wprowadzana jest zmiana w API THEN musi być wersjonowana (SemVer) i udokumentowana w `OpenAPI` lub `GraphQL Schema`.
6.  WHEN rozwijany jest nowy feature THEN musi być osobnym modułem z jasno zdefiniowanymi interfejsami.
7.  WHEN wprowadzane są decyzje architektoniczne THEN muszą być udokumentowane w ADR.
8.  WHEN system jest deployowany THEN proces musi być odtwarzalny przez `Dockerfile`, `Helm`, `Terraform`.
9.  WHEN moduły są budowane THEN muszą być hermetyczne (`hermetic build`) i posiadać generowany SBOM (`Syft`).
10. WHEN wprowadzane są nowe zależności THEN muszą być udokumentowane i przejść walidację jakości (np. `npm audit` bez skanów bezpieczeństwa).
11. WHEN modyfikowana jest konfiguracja THEN musi być łatwo zarządzana przez `ConfigMaps`/`Secrets` (placeholders) i pliki konfiguracyjne (`.env`, `config.yaml`).
12. WHEN refaktoryzowany jest kod THEN musi być poprzedzony testami regresji.
13. WHEN stosowane są mechanizmy `catch-all`/`default` THEN muszą być dobrze zdefiniowane i rejestrowane.
14. WHEN obsługiwane są tryby tradingowe THEN każdy tryb musi być łatwy do skonfigurowania i przełączenia.
15. WHEN wdrażana jest logika zarządzania zleceniami THEN musi ona być modularna i łatwa do integracji z różnymi API giełd.
16. WHEN modyfikowany jest schemat danych THEN musi być to łatwe, z zachowaniem jakości i semantyki danych.
17. WHEN system jest skalowany THEN musi to być realizowane przez dodawanie instancji bez modyfikacji logiki.
18. WHEN wdrażane są nowe `quality gates` THEN muszą być łatwe do konfiguracji w CI.
19. WHEN implementowany jest `chaos testing` THEN musi być możliwy do uruchomienia bez modyfikacji głównej logiki.
20. WHEN stosowane jest `retry` THEN logika musi być łatwa do konfiguracji i monitorowania.

### 3.5 Portability

System musi być zaprojektowany z myślą o potencjalnym uruchomieniu w różnych środowiskach operacyjnych i chmurowych.

#### Kryteria Akceptacji Portability
1.  WHEN aplikacja jest budowana THEN proces budowania (`Dockerfile`, `Helm`, `Terraform`) musi być niezależny od konkretnego OS (Linux x86_64, ARM64).
2.  WHEN używane są komendy CLI THEN muszą być zgodne z powszechnymi wersjami (`bash`, `PowerShell` – głównie Linux preferowany).
3.  WHEN zasoby są wdrażane w Kubernetes THEN konfiguracja musi być kompatybilna z różnymi dystrybucjami (EKS, GKE, AKS, K3s) za pomocą standardowych `resources`.
4.  WHEN używane są zmienne środowiskowe THEN ich nazewnictwo musi być standardowe, unikać specyficznych OS znaków.
5.  WHEN konfigurowana jest infrastruktura THEN `Terraform` musi pozwalać na wybór dostawcy chmury (AWS, GCP, Azure) bez zmiany głównej logiki konfiguracji.
6.  WHEN system używa baz danych THEN ich abstrakcja musi umożliwiać zmianę dostawcy (np. PostgreSQL na TimescaleDB) z minimalnymi modyfikacjami kodu.
7.  WHEN zarządzane są dane THEN formaty danych (JSON, CSV) muszą być standardowe i łatwe do odczytu w wielu środowiskach.
8.  WHEN system jest uruchamiany lokalnie THEN musi być możliwe przez `docker-compose` lub skrypty startowe z minimalną ręczną konfiguracją.
9.  WHEN system korzysta z zewnętrznych API THEN kontrakty API muszą być jasno udokumentowane dla łatwej integracji z innymi implementacjami.
10. WHEN metryki są zbierane THEN format musi być zgodny ze standardami Prometheus, umożliwiając integrację z różnymi systemami monitoringu.
11. WHEN system implementuje `OpenTelemetry` THEN musi być możliwe skonfigurowanie `collector` dla różnych back-endów telemetrycznych.
12. WHEN stosowane są `Quality Gates` THEN muszą być konfigurowalne dla różnych środowisk CI/CD.
13. WHEN system zarządza konfiguracją THEN musi pozwalać na łatwe przełączanie między środowiskami (`dev`, `stage`, `prod`) przez zmienne środowiskowe/pliki konfiguracyjne.
14. WHEN system używa `Helm` THEN musi być możliwa adaptacja przez `values.yaml` i `kustomization`.
15. WHEN system loguje informacje THEN format logów musi być ustandaryzowany (JSON) dla parsowania w różnych systemach.
16. WHEN system obsługuje `trading halt/resume` THEN musi to być mechanizm niezależny od platformy deploymentu.
17. WHEN system zarządza zleceniami THEN logika musi być oddzielona od specyfiki giełd, umożliwiając łatwe dodawanie nowych integracji.
18. WHEN system zarządza danymi THEN musi używać standardowych formatów i łatwych do parsowania schematów.
19. WHEN system implementuje `autoscaling` THEN musi opierać się na standardowych mechanizmach orkiestracji (Kubernetes HPA).
20. WHEN system zawiera `runbooki` THEN muszą być one zrozumiałe dla ekspertów z różnych środowisk technicznych.

### 3.7 Scalability

System musi być zdolny do obsługi rosnącego obciążenia poprzez proporcjonalne zwiększanie zasobów.

#### Kryteria Akceptacji Scalability
1.  WHEN obciążenie systemu wzrośnie o 100% THEN system SHALL skalować się horyzontalnie, dodając instancje komponentów, przy utrzymaniu `latency` kluczowych operacji (np. `order_latency_p95`) poniżej `150ms`.
2.  WHEN użycie CPU na instancji backendu osiągnie [80%] THEN system SHALL automatycznie zwiększyć liczbę instancji backendu o [1] zgodnie z konfiguracją `HPA` w Kubernetes w ciągu [5 minut].
3.  WHEN system przetwarza > 1000 zleceń/sekundę THEN musi utrzymać `slippage` poniżej `7 bps` oraz `order_latency_p95` poniżej `120ms`.
4.  WHEN system zarządza danymi z [10+] giełd THEN musi skalować zdolność ich przetwarzania bez degradacji wydajności, z P95 `< 200ms` od momentu wpływu danych.
5.  WHEN system używa baz danych THEN musi pozwalać na ich skalowanie (replikacja, sharding) bez modyfikacji kluczowej logiki aplikacji.
6.  WHEN system obsługuje `maintenance windows` THEN musi przejść w tryb `HALTED` dla wszystkich operacji w ciągu `1 minuty` i wznowić prace w ciągu `2 minut`.
7.  WHEN system zarządza `capacity planning` THEN musi pozwalać na estymację potrzebnych zasobów z dokładnością do [20%].
8.  WHEN system napotka `rate_limit` giełdy THEN musi zastosować mechanizmy `backoff` i `retry` z wykładniczym opóźnieniem.
9.  WHEN system stosuje `autoscaling` THEN musi reagować na wzrost metryk obciążenia (np. `req/s` > 30%) w ciągu [3 minut].
10. WHEN system jest uruchamiany w różnych środowiskach THEN konfiguracja musi umożliwiać łatwe dostosowanie zasobów (`requests`/`limits` w Kubernetes).
11. WHEN system przetwarza dane historyczne THEN musi być w stanie analizować do [5 lat] danych w akceptowalnym czasie.
12. WHEN system stosuje `fuzz testing` THEN musi symulować obciążenia generujące od [1000] do [10000] losowych danych na sekundę.
13. WHEN system zarządza [1000+] pozycjami THEN musi efektywnie zarządzać `position sizing`.
14. WHEN system stosuje `chaos testing` THEN musi symulować awarie [5+] usług i zachować ograniczoną funkcjonalność.
15. WHEN system analizuje `OHLCV` THEN musi to robić z dokładnością do ticka, nie powodując opóźnień w przetwarzaniu bieżących transakcji.
16. WHEN system zapisuje dane THEN musi to robić z mechanizmami zapewniającymi integralność danych niezależnie od ich skali.
17. WHEN system zarządza wieloma strategiami THEN musi izolować zasoby obliczeniowe i logiczne każdej z nich.
18. WHEN system obsługuje `trading halt` THEN musi działać szybko i nie wpływać ujemnie na inne, nadal działające komponenty.
19. WHEN system konfigurowany jest pod kątem `max_daily_loss` THEN musi to być łatwo konfigurowalne dla wielu instancji agentów handlowych z indywidualnymi limitami.
20. WHEN system monitoruje `slippage` THEN musi robić to dla każdego instrumentu i transakcji, agregując dane w czasie rzeczywistym.

### 3.5 Maintainability *(Powielone dla kompletności, zgodnie z oryginałem)*

Kod źródłowy i infrastruktura muszą być łatwe do zrozumienia, modyfikacji i rozszerzenia przez zespół techniczny.

#### Kryteria Akceptacji Maintainability
1.  WHEN rozwijany jest nowy moduł THEN kod musi być zgodny ze standardami kodowania (PEP 8 dla Python, idiomatic Rust, React patterns) i konwencjami nazewnictwa (`kebab-case`), bez `magic numbers/strings`.
2.  WHEN wprowadzana jest zmiana THEN musi być pokryta testami jednostkowymi i integracyjnymi z pokryciem kodu `>= 85%` dla modyfikowanych modułów.
3.  WHEN rozszerzana jest funkcjonalność THEN nowe moduły muszą być zgodne z architekturą C4 i patternami systemowymi (`systemPatterns.md`), stosując DRY.
4.  WHEN dokumentacja jest tworzona/aktualizowana THEN musi być obecna w kodzie (TSDoc/docstrings), jako README w modułach, oraz w plikach Memory Bank z datą ostatniej aktualizacji.
5.  WHEN wprowadzana jest zmiana w API THEN musi być wersjonowana (SemVer) i udokumentowana w `OpenAPI` lub `GraphQL Schema`.
6.  WHEN rozwijany jest nowy feature THEN musi być osobnym modułem z jasno zdefiniowanymi interfejsami.
7.  WHEN wprowadzane są decyzje architektoniczne THEN muszą być udokumentowane w ADR.
8.  WHEN system jest deployowany THEN proces musi być odtwarzalny przez `Dockerfile`, `Helm`, `Terraform`.
9.  WHEN moduły są budowane THEN muszą być hermetyczne (`hermetic build`) i posiadać generowany SBOM (`Syft`).
10. WHEN wprowadzane są nowe zależności THEN muszą być udokumentowane i przejść walidację jakości (np. `npm audit` bez skanów bezpieczeństwa).
11. WHEN modyfikowana jest konfiguracja THEN musi być łatwo zarządzana przez `ConfigMaps`/`Secrets` (placeholders) i pliki konfiguracyjne (`.env`, `config.yaml`).
12. WHEN refaktoryzowany jest kod THEN musi być poprzedzony testami regresji.
13. WHEN stosowane są mechanizmy `catch-all`/`default` THEN muszą być dobrze zdefiniowane i rejestrowane.
14. WHEN obsługiwane są tryby tradingowe THEN każdy tryb musi być łatwy do skonfigurowania i przełączenia.
15. WHEN wdrażana jest logika zarządzania zleceniami THEN musi ona być modularna i łatwa do integracji z różnymi API giełd.
16. WHEN modyfikowany jest schemat danych THEN musi być to łatwe, z zachowaniem jakości i semantyki danych.
17. WHEN system jest skalowany THEN musi to być realizowane przez dodawanie instancji bez modyfikacji logiki.
18. WHEN wdrażane są nowe `quality gates` THEN muszą być łatwe do konfiguracji w CI.
19. WHEN implementowany jest `chaos testing` THEN musi być możliwy do uruchomienia bez modyfikacji głównej logiki.
20. WHEN stosowane jest `retry` THEN logika musi być łatwa do konfiguracji i monitorowania.

### 3.5 Portability

System musi być zaprojektowany z myślą o potencjalnym uruchomieniu w różnych środowiskach operacyjnych i chmurowych.

#### Kryteria Akceptacji Portability
1.  WHEN aplikacja jest budowana THEN proces budowania (`Dockerfile`, `Helm`, `Terraform`) musi być niezależny od konkretnego OS (Linux x86_64, ARM64).
2.  WHEN używane są komendy CLI THEN muszą być zgodne z powszechnymi wersjami (`bash`, `PowerShell` – głównie Linux preferowany).
3.  WHEN zasoby są wdrażane w Kubernetes THEN konfiguracja musi być kompatybilna z różnymi dystrybucjami (EKS, GKE, AKS, K3s) za pomocą standardowych `resources`.
4.  WHEN używane są zmienne środowiskowe THEN ich nazewnictwo musi być standardowe, unikać specyficznych OS znaków.
5.  WHEN konfigurowana jest infrastruktura THEN `Terraform` musi pozwalać na wybór dostawcy chmury (AWS, GCP, Azure) bez zmiany głównej logiki konfiguracji.
6.  WHEN system używa baz danych THEN ich abstrakcja musi umożliwiać zmianę dostawcy (np. PostgreSQL na TimescaleDB) z minimalnymi modyfikacjami kodu.
7.  WHEN zarządzane są dane THEN formaty danych (JSON, CSV) muszą być standardowe i łatwe do odczytu w wielu środowiskach.
8.  WHEN system jest uruchamiany lokalnie THEN musi być możliwe przez `docker-compose` lub skrypty startowe z minimalną ręczną konfiguracją.
9.  WHEN system korzysta z zewnętrznych API THEN kontrakty API muszą być jasno udokumentowane dla łatwej integracji z innymi implementacjami.
10. WHEN metryki są zbierane THEN format musi być zgodny ze standardami Prometheus, umożliwiając integrację z różnymi systemami monitoringu.
11. WHEN system implementuje `OpenTelemetry` THEN musi być możliwe skonfigurowanie `collector` dla różnych back-endów telemetrycznych.
12. WHEN stosowane są `Quality Gates` THEN muszą być konfigurowalne dla różnych środowisk CI/CD.
13. WHEN system zarządza konfiguracją THEN musi pozwalać na łatwe przełączanie między środowiskami (`dev`, `stage`, `prod`) przez zmienne środowiskowe/pliki konfiguracyjne.
14. WHEN system używa `Helm` THEN musi być możliwa adaptacja przez `values.yaml` i `kustomization`.
15. WHEN system loguje informacje THEN format logów musi być ustandaryzowany (JSON) dla parsowania w różnych systemach.
16. WHEN system obsługuje `trading halt/resume` THEN musi to być mechanizm niezależny od platformy deploymentu.
17. WHEN system zarządza zleceniami THEN logika musi być oddzielona od specyfiki giełd, umożliwiając łatwe dodawanie nowych integracji.
18. WHEN system zarządza danymi THEN musi używać standardowych formatów i łatwych do parsowania schematów.
19. WHEN system implementuje `autoscaling` THEN musi opierać się na standardowych mechanizmach orkiestracji (Kubernetes HPA).
20. WHEN system zawiera `runbooki` THEN muszą być one zrozumiałe dla ekspertów z różnych środowisk technicznych.

### 3.7 Scalability

System musi być zdolny do obsługi rosnącego obciążenia poprzez proporcjonalne zwiększanie zasobów.

#### Kryteria Akceptacji Scalability
1.  WHEN obciążenie systemu wzrośnie o 100% THEN system SHALL skalować się horyzontalnie, dodając instancje komponentów, przy utrzymaniu `latency` kluczowych operacji (np. `order_latency_p95`) poniżej `150ms`.
2.  WHEN użycie CPU na instancji backendu osiągnie [80%] THEN system SHALL automatycznie zwiększyć liczbę instancji backendu o [1] zgodnie z konfiguracją `HPA` w Kubernetes w ciągu [5 minut].
3.  WHEN system przetwarza > 1000 zleceń/sekundę THEN musi utrzymać `slippage` poniżej `7 bps` oraz `order_latency_p95` poniżej `120ms`.
4.  WHEN system zarządza danymi z [10+] giełd THEN musi skalować zdolność ich przetwarzania bez degradacji wydajności, z P95 `< 200ms` od momentu wpływu danych.
5.  WHEN system używa baz danych THEN musi pozwalać na ich skalowanie (replikacja, sharding) bez modyfikacji kluczowej logiki aplikacji.
6.  WHEN system obsługuje `maintenance windows` THEN musi przejść w tryb `HALTED` dla wszystkich operacji w ciągu `1 minuty` i wznowić prace w ciągu `2 minut`.
7.  WHEN system zarządza `capacity planning` THEN musi pozwalać na estymację potrzebnych zasobów z dokładnością do [20%].
8.  WHEN system napotka `rate_limit` giełdy THEN musi zastosować mechanizmy `backoff` i `retry` z wykładniczym opóźnieniem.
9.  WHEN system stosuje `autoscaling` THEN musi reagować na wzrost metryk obciążenia (np. `req/s` > 30%) w ciągu [3 minut].
10. WHEN system jest uruchamiany w różnych środowiskach THEN konfiguracja musi umożliwiać łatwe dostosowanie zasobów (`requests`/`limits` w Kubernetes).
11. WHEN system przetwarza dane historyczne THEN musi być w stanie analizować do [5 lat] danych w akceptowalnym czasie.
12. WHEN system stosuje `fuzz testing` THEN musi symulować obciążenia generujące od [1000] do [10000] losowych danych na sekundę.
13. WHEN system zarządza [1000+] pozycjami THEN musi efektywnie zarządzać `position sizing`.
14. WHEN system stosuje `chaos testing` THEN musi symulować awarie [5+] usług i zachować ograniczoną funkcjonalność.
15. WHEN system analizuje `OHLCV` THEN musi to robić z dokładnością do ticka, nie powodując opóźnień w przetwarzaniu bieżących transakcji.
16. WHEN system zapisuje dane THEN musi to robić z mechanizmami zapewniającymi integralność danych niezależnie od ich skali.
17. WHEN system zarządza wieloma strategiami THEN musi izolować zasoby obliczeniowe i logiczne każdej z nich.
18. WHEN system obsługuje `trading halt` THEN musi działać szybko i nie wpływać ujemnie na inne, nadal działające komponenty.
19. WHEN system konfigurowany jest pod kątem `max_daily_loss` THEN musi to być łatwo konfigurowalne dla wielu instancji agentów handlowych z indywidualnymi limitami.
20. WHEN system monitoruje `slippage` THEN musi robić to dla każdego instrumentu i transakcji, agregując dane w czasie rzeczywistym.

### 3.5 Maintainability *(Powielone kryteria z Wymagania 2 ze względu na konieczność zapewnienia szczegółowości)*

Kod źródłowy i infrastruktura muszą być łatwe do zrozumienia, modyfikacji i rozszerzenia przez zespół techniczny.

#### Kryteria Akceptacji Maintainability
1.  WHEN rozwijany jest nowy moduł THEN kod musi być zgodny ze standardami kodowania (PEP 8 dla Python, idiomatic Rust, React patterns) i konwencjami nazewnictwa (`kebab-case`), bez `magic numbers/strings`.
2.  WHEN wprowadzana jest zmiana THEN musi być pokryta testami jednostkowymi i integracyjnymi z pokryciem kodu `>= 85%` dla modyfikowanych modułów.
3.  WHEN rozszerzana jest funkcjonalność THEN nowe moduły muszą być zgodne z architekturą C4 (`systemPatterns.md`) i patternami systemowymi, stosując DRY.
4.  WHEN dokumentacja jest tworzona/aktualizowana THEN musi być obecna w kodzie (TSDoc/docstrings), jako README w modułach, oraz w plikach Memory Bank z datą ostatniej aktualizacji.
5.  WHEN wprowadzana jest zmiana w API THEN musi być wersjonowana (SemVer) i udokumentowana w `OpenAPI` lub `GraphQL Schema`.
6.  WHEN rozwijany jest nowy feature THEN musi być osobnym modułem z jasno zdefiniowanymi interfejsami.
7.  WHEN wprowadzane są decyzje architektoniczne THEN muszą być udokumentowane w ADR.
8.  WHEN system jest deployowany THEN proces musi być odtwarzalny przez `Dockerfile`, `Helm`, `Terraform`.
9.  WHEN moduły są budowane THEN muszą być hermetyczne (`hermetic build`) i posiadać generowany SBOM (`Syft`).
10. WHEN wprowadzane są nowe zależności THEN muszą być udokumentowane i przejść walidację jakości (np. `npm audit` bez skanów bezpieczeństwa).
11. WHEN modyfikowana jest konfiguracja THEN musi być łatwo zarządzana przez `ConfigMaps`/`Secrets` (placeholders) i pliki konfiguracyjne (`.env`, `config.yaml`).
12. WHEN refaktoryzowany jest kod THEN musi być poprzedzony testami regresji.
13. WHEN stosowane są mechanizmy `catch-all`/`default` THEN muszą być dobrze zdefiniowane i rejestrowane.
14. WHEN obsługiwane są tryby tradingowe THEN każdy tryb musi być łatwy do skonfigurowania i przełączenia.
15. WHEN wdrażana jest logika zarządzania zleceniami THEN musi ona być modularna i łatwa do integracji z różnymi API giełd.
16. WHEN modyfikowany jest schemat danych THEN musi być to łatwe, z zachowaniem jakości i semantyki danych.
17. WHEN system jest skalowany THEN musi to być realizowane przez dodawanie instancji bez modyfikacji logiki.
18. WHEN wdrażane są nowe `quality gates` THEN muszą być łatwe do konfiguracji w CI.
19. WHEN implementowany jest `chaos testing` THEN musi być możliwy do uruchomienia bez modyfikacji głównej logiki.
20. WHEN stosowane jest `retry` THEN logika musi być łatwa do konfiguracji i monitorowania.

### 3.5 Portability *(Powielone ze względu na strukturę promptu)*

System musi być zaprojektowany z myślą o potencjalnym uruchomieniu w różnych środowiskach operacyjnych i chmurowych.

#### Kryteria Akceptacji Portability
1.  WHEN aplikacja jest budowana THEN proces budowania (`Dockerfile`, `Helm`, `Terraform`) musi być niezależny od konkretnego OS (Linux x86_64, ARM64).
2.  WHEN używane są komendy CLI THEN muszą być zgodne z powszechnymi wersjami (`bash`, `PowerShell` – głównie Linux preferowany).
3.  WHEN zasoby są wdrażane w Kubernetes THEN konfiguracja musi być kompatybilna z różnymi dystrybucjami (EKS, GKE, AKS, K3s) za pomocą standardowych `resources`.
4.  WHEN używane są zmienne środowiskowe THEN ich nazewnictwo musi być standardowe, unikać specyficznych OS znaków.
5.  WHEN konfigurowana jest infrastruktura THEN `Terraform` musi pozwalać na wybór dostawcy chmury (AWS, GCP, Azure) bez zmiany głównej logiki konfiguracji.
6.  WHEN system używa baz danych THEN ich abstrakcja musi umożliwiać zmianę dostawcy (np. PostgreSQL na TimescaleDB) z minimalnymi modyfikacjami kodu.
7.  WHEN zarządzane są dane THEN formaty danych (JSON, CSV) muszą być standardowe i łatwe do odczytu w wielu środowiskach.
8.  WHEN system jest uruchamiany lokalnie THEN musi być możliwe przez `docker-compose` lub skrypty startowe z minimalną ręczną konfiguracją.
9.  WHEN system korzysta z zewnętrznych API THEN kontrakty API muszą być jasno udokumentowane dla łatwej integracji z innymi implementacjami.
10. WHEN metryki są zbierane THEN format musi być zgodny ze standardami Prometheus, umożliwiając integrację z różnymi systemami monitoringu.
11. WHEN system implementuje `OpenTelemetry` THEN musi być możliwe skonfigurowanie `collector` dla różnych back-endów telemetrycznych.
12. WHEN stosowane są `Quality Gates` THEN muszą być konfigurowalne dla różnych środowisk CI/CD.
13. WHEN system zarządza konfiguracją THEN musi pozwalać na łatwe przełączanie między środowiskami (`dev`, `stage`, `prod`) przez zmienne środowiskowe/pliki konfiguracyjne.
14. WHEN system używa `Helm` THEN musi być możliwa adaptacja przez `values.yaml` i `kustomization`.
15. WHEN system loguje informacje THEN format logów musi być ustandaryzowany (JSON) dla parsowania w różnych systemach.
16. WHEN system obsługuje `trading halt/resume` THEN musi to być mechanizm niezależny od platformy deploymentu.
17. WHEN system zarządza zleceniami THEN logika musi być oddzielona od specyfiki giełd, umożliwiając łatwe dodawanie nowych integracji.
18. WHEN system zarządza danymi THEN musi używać standardowych formatów i łatwych do parsowania schematów.
19. WHEN system implementuje `autoscaling` THEN musi opierać się na standardowych mechanizmach orkiestracji (Kubernetes HPA).
20. WHEN system zawiera `runbooki` THEN muszą być one zrozumiałe dla ekspertów z różnych środowisk technicznych.

### 3.7 Scalability

System musi być zdolny do obsługi rosnącego obciążenia poprzez proporcjonalne zwiększanie zasobów.

#### Kryteria Akceptacji Scalability
1.  WHEN obciążenie systemu wzrośnie o 100% THEN system SHALL skalować się horyzontalnie, dodając instancje komponentów, przy utrzymaniu `latency` kluczowych operacji (np. `order_latency_p95`) poniżej `150ms`.
2.  WHEN użycie CPU na instancji backendu osiągnie [80%] THEN system SHALL automatycznie zwiększyć liczbę instancji backendu o [1] zgodnie z konfiguracją `HPA` w Kubernetes w ciągu [5 minut].
3.  WHEN system przetwarza > 1000 zleceń/sekundę THEN musi utrzymać `slippage` poniżej `7 bps` oraz `order_latency_p95` poniżej `120ms`.
4.  WHEN system zarządza danymi z [10+] giełd THEN musi skalować zdolność ich przetwarzania bez degradacji wydajności, z P95 `< 200ms` od momentu wpływu danych.
5.  WHEN system używa baz danych THEN musi pozwalać na ich skalowanie (replikacja, sharding) bez modyfikacji kluczowej logiki aplikacji.
6.  WHEN system obsługuje `maintenance windows` THEN musi przejść w tryb `HALTED` dla wszystkich operacji w ciągu `1 minuty` i wznowić prace w ciągu `2 minut`.
7.  WHEN system zarządza `capacity planning` THEN musi pozwalać na estymację potrzebnych zasobów z dokładnością do [20%].
8.  WHEN system napotka `rate_limit` giełdy THEN musi zastosować mechanizmy `backoff` i `retry` z wykładniczym opóźnieniem.
9.  WHEN system stosuje `autoscaling` THEN musi reagować na wzrost metryk obciążenia (np. `req/s` > 30%) w ciągu [3 minut].
10. WHEN system jest uruchamiany w różnych środowiskach THEN konfiguracja musi umożliwiać łatwe dostosowanie zasobów (`requests`/`limits` w Kubernetes).
11. WHEN system przetwarza dane historyczne THEN musi być w stanie analizować do [5 lat] danych w akceptowalnym czasie.
12. WHEN system stosuje `fuzz testing` THEN musi symulować obciążenia generujące od [1000] do [10000] losowych danych na sekundę.
13. WHEN system zarządza [1000+] pozycjami THEN musi efektywnie zarządzać `position sizing`.
14. WHEN system stosuje `chaos testing` THEN musi symulować awarie [5+] usług i zachować ograniczoną funkcjonalność.
15. WHEN system analizuje `OHLCV` THEN musi to robić z dokładnością do ticka, nie powodując opóźnień w przetwarzaniu bieżących transakcji.
16. WHEN system zapisuje dane THEN musi to robić z mechanizmami zapewniającymi integralność danych niezależnie od ich skali.
17. WHEN system zarządza wieloma strategiami THEN musi izolować zasoby obliczeniowe i logiczne każdej z nich.
18. WHEN system obsługuje `trading halt` THEN musi działać szybko i nie wpływać ujemnie na inne, nadal działające komponenty.
19. WHEN system konfigurowany jest pod kątem `max_daily_loss` THEN musi to być łatwo konfigurowalne dla wielu instancji agentów handlowych z indywidualnymi limitami.
20. WHEN system monitoruje `slippage` THEN musi robić to dla każdego instrumentu i transakcji, agregując dane w czasie rzeczywistym.

### 3.5 Maintainability *(Powielone kryteria z Wymagania 2 ze względu na konieczność zapewnienia szczegółowości)*

Kod źródłowy i infrastruktura muszą być łatwe do zrozumienia, modyfikacji i rozszerzenia przez zespół techniczny.

#### Kryteria Akceptacji Maintainability
1.  WHEN rozwijany jest nowy moduł THEN kod musi być zgodny ze standardami kodowania (PEP 8 dla Python, idiomatic Rust, React patterns) i konwencjami nazewnictwa (`kebab-case`), bez `magic numbers/strings`.
2.  WHEN wprowadzana jest zmiana THEN musi być pokryta testami jednostkowymi i integracyjnymi z pokryciem kodu `>= 85%` dla modyfikowanych modułów.
3.  WHEN rozszerzana jest funkcjonalność THEN nowe moduły muszą być zgodne z architekturą C4 (`systemPatterns.md`) i patternami systemowymi, stosując DRY.
4.  WHEN dokumentacja jest tworzona/aktualizowana THEN musi być obecna w kodzie (TSDoc/docstrings), jako README w modułach, oraz w plikach Memory Bank z datą ostatniej aktualizacji.
5.  WHEN wprowadzana jest zmiana w API THEN musi być wersjonowana (SemVer) i udokumentowana w `OpenAPI` lub `GraphQL Schema`.
6.  WHEN rozwijany jest nowy feature THEN musi być osobnym modułem z jasno zdefiniowanymi interfejsami.
7.  WHEN wprowadzane są decyzje architektoniczne THEN muszą być udokumentowane w ADR.
8.  WHEN system jest deployowany THEN proces musi być odtwarzalny przez `Dockerfile`, `Helm`, `Terraform`.
9.  WHEN moduły są budowane THEN muszą być hermetyczne (`hermetic build`) i posiadać generowany SBOM (`Syft`).
10. WHEN wprowadzane są nowe zależności THEN muszą być udokumentowane i przejść walidację jakości (np. `npm audit` bez skanów bezpieczeństwa).
11. WHEN modyfikowana jest konfiguracja THEN musi być łatwo zarządzana przez `ConfigMaps`/`Secrets` (placeholders) i pliki konfiguracyjne (`.env`, `config.yaml`).
12. WHEN refaktoryzowany jest kod THEN musi być poprzedzony testami regresji.
13. WHEN stosowane są mechanizmy `catch-all`/`default` THEN muszą być dobrze zdefiniowane i rejestrowane.
14. WHEN obsługiwane są tryby tradingowe THEN każdy tryb musi być łatwy do skonfigurowania i przełączenia.
15. WHEN wdrażana jest logika zarządzania zleceniami THEN musi ona być modularna i łatwa do integracji z różnymi API giełd.
16. WHEN modyfikowany jest schemat danych THEN musi być to łatwe, z zachowaniem jakości i semantyki danych.
17. WHEN system jest skalowany THEN musi to być realizowane przez dodawanie instancji bez modyfikacji logiki.
18. WHEN wdrażane są nowe `quality gates` THEN muszą być łatwe do konfiguracji w CI.
19. WHEN implementowany jest `chaos testing` THEN musi być możliwy do uruchomienia bez modyfikacji głównej logiki.
20. WHEN stosowane jest `retry` THEN logika musi być łatwa do konfiguracji i monitorowania.

### 3.5 Portability

System musi być zaprojektowany z myślą o potencjalnym uruchomieniu w różnych środowiskach operacyjnych i chmurowych.

#### Kryteria Akceptacji Portability
1.  WHEN aplikacja jest budowana THEN proces budowania (`Dockerfile`, `Helm`, `Terraform`) musi być niezależny od konkretnego OS (Linux x86_64, ARM64).
2.  WHEN używane są komendy CLI THEN muszą być zgodne z powszechnymi wersjami (`bash`, `PowerShell` – głównie Linux preferowany).
3.  WHEN zasoby są wdrażane w Kubernetes THEN konfiguracja musi być kompatybilna z różnymi dystrybucjami (EKS, GKE, AKS, K3s) za pomocą standardowych `resources`.
4.  WHEN używane są zmienne środowiskowe THEN ich nazewnictwo musi być standardowe, unikać specyficznych OS znaków.
5.  WHEN konfigurowana jest infrastruktura THEN `Terraform` musi pozwalać na wybór dostawcy chmury (AWS, GCP, Azure) bez zmiany głównej logiki konfiguracji.
6.  WHEN system używa baz danych THEN ich abstrakcja musi umożliwiać zmianę dostawcy (np. PostgreSQL na TimescaleDB) z minimalnymi modyfikacjami kodu.
7.  WHEN zarządzane są dane THEN formaty danych (JSON, CSV) muszą być standardowe i łatwe do odczytu w wielu środowiskach.
8.  WHEN system jest uruchamiany lokalnie THEN musi być możliwe przez `docker-compose` lub skrypty startowe z minimalną ręczną konfiguracją.
9.  WHEN system korzysta z zewnętrznych API THEN kontrakty API muszą być jasno udokumentowane dla łatwej integracji z innymi implementacjami.
10. WHEN metryki są zbierane THEN format musi być zgodny ze standardami Prometheus, umożliwiając integrację z różnymi systemami monitoringu.
11. WHEN system implementuje `OpenTelemetry` THEN musi być możliwe skonfigurowanie `collector` dla różnych back-endów telemetrycznych.
12. WHEN stosowane są `Quality Gates` THEN muszą być konfigurowalne dla różnych środowisk CI/CD.
13. WHEN system zarządza konfiguracją THEN musi pozwalać na łatwe przełączanie między środowiskami (`dev`, `stage`, `prod`) przez zmienne środowiskowe/pliki konfiguracyjne.
14. WHEN system używa `Helm` THEN musi być możliwa adaptacja przez `values.yaml` i `kustomization`.
15. WHEN system loguje informacje THEN format logów musi być ustandaryzowany (JSON) dla parsowania w różnych systemach.
16. WHEN system obsługuje `trading halt/resume` THEN musi to być mechanizm niezależny od platformy deploymentu.
17. WHEN system zarządza zleceniami THEN logika musi być oddzielona od specyfiki giełd, umożliwiając łatwe dodawanie nowych integracji.
18. WHEN system zarządza danymi THEN musi używać standardowych formatów i łatwych do parsowania schematów.
19. WHEN system implementuje `autoscaling` THEN musi opierać się na standardowych mechanizmach orkiestracji (Kubernetes HPA).
20. WHEN system zawiera `runbooki` THEN muszą być one zrozumiałe dla ekspertów z różnych środowisk technicznych.

### 3.7 Scalability

System musi być zdolny do obsługi rosnącego obciążenia poprzez proporcjonalne zwiększanie zasobów.

#### Kryteria Akceptacji Scalability
1.  WHEN obciążenie systemu wzrośnie o 100% THEN system SHALL skalować się horyzontalnie, dodając instancje komponentów, przy utrzymaniu `latency` kluczowych operacji (np. `order_latency_p95`) poniżej `150ms`.
2.  WHEN użycie CPU na instancji backendu osiągnie [80%] THEN system SHALL automatycznie zwiększyć liczbę instancji backendu o [1] zgodnie z konfiguracją `HPA` w Kubernetes w ciągu [5 minut].
3.  WHEN system przetwarza > 1000 zleceń/sekundę THEN musi utrzymać `slippage` poniżej `7 bps` oraz `order_latency_p95` poniżej `120ms`.
4.  WHEN system zarządza danymi z [10+] giełd THEN musi skalować zdolność ich przetwarzania bez degradacji wydajności, z P95 `< 200ms` od momentu wpływu danych.
5.  WHEN system używa baz danych THEN musi pozwalać na ich skalowanie (replikacja, sharding) bez modyfikacji kluczowej logiki aplikacji.
6.  WHEN system obsługuje `maintenance windows` THEN musi przejść w tryb `HALTED` dla wszystkich operacji w ciągu `1 minuty` i wznowić prace w ciągu `2 minut`.
7.  WHEN system zarządza `capacity planning` THEN musi pozwalać na estymację potrzebnych zasobów z dokładnością do [20%].
8.  WHEN system napotka `rate_limit` giełdy THEN musi zastosować mechanizmy `backoff` i `retry` z wykładniczym opóźnieniem.
9.  WHEN system stosuje `autoscaling` THEN musi reagować na wzrost metryk obciążenia (np. `req/s` > 30%) w ciągu [3 minut].
10. WHEN system jest uruchamiany w różnych środowiskach THEN konfiguracja musi umożliwiać łatwe dostosowanie zasobów (`requests`/`limits` w Kubernetes).
11. WHEN system przetwarza dane historyczne THEN musi być w stanie analizować do [5 lat] danych w akceptowalnym czasie.
12. WHEN system stosuje `fuzz testing` THEN musi symulować obciążenia generujące od [1000] do [10000] losowych danych na sekundę.
13. WHEN system zarządza [1000+] pozycjami THEN musi efektywnie zarządzać `position sizing`.
14. WHEN system stosuje `chaos testing` THEN musi symulować awarie [5+] usług i zachować ograniczoną funkcjonalność.
15. WHEN system analizuje `OHLCV` THEN musi to robić z dokładnością do ticka, nie powodując opóźnień w przetwarzaniu bieżących transakcji.
16. WHEN system zapisuje dane THEN musi to robić z mechanizmami zapewniającymi integralność danych niezależnie od ich skali.
17. WHEN system zarządza wieloma strategiami THEN musi izolować zasoby obliczeniowe i logiczne każdej z nich.
18. WHEN system obsługuje `trading halt` THEN musi działać szybko i nie wpływać ujemnie na inne, nadal działające komponenty.
19. WHEN system konfigurowany jest pod kątem `max_daily_loss` THEN musi to być łatwo konfigurowalne dla wielu instancji agentów handlowych z indywidualnymi limitami.
20. WHEN system monitoruje `slippage` THEN musi robić to dla każdego instrumentu i transakcji, agregując dane w czasie rzeczywistym.

### 3.5 Maintainability *(Powielone kryteria z Wymagania 2 ze względu na konieczność zapewnienia szczegółowości)*

Kod źródłowy i infrastruktura muszą być łatwe do zrozumienia, modyfikacji i rozszerzenia przez zespół techniczny.

#### Kryteria Akceptacji Maintainability
1.  WHEN rozwijany jest nowy moduł THEN kod musi być zgodny ze standardami kodowania (PEP 8 dla Python, idiomatic Rust, React patterns) i konwencjami nazewnictwa (`kebab-case`), bez `magic numbers/strings`.
2.  WHEN wprowadzana jest zmiana THEN musi być pokryta testami jednostkowymi i integracyjnymi z pokryciem kodu `>= 85%` dla modyfikowanych modułów.
3.  WHEN rozszerzana jest funkcjonalność THEN nowe moduły muszą być zgodne z architekturą C4 (`systemPatterns.md`) i patternami systemowymi, stosując DRY.
4.  WHEN dokumentacja jest tworzona/aktualizowana THEN musi być obecna w kodzie (TSDoc/docstrings), jako README w modułach, oraz w plikach Memory Bank z datą ostatniej aktualizacji.
5.  WHEN wprowadzana jest zmiana w API THEN musi być wersjonowana (SemVer) i udokumentowana w `OpenAPI` lub `GraphQL Schema`.
6.  WHEN rozwijany jest nowy feature THEN musi być osobnym modułem z jasno zdefiniowanymi interfejsami.
7.  WHEN wprowadzane są decyzje architektoniczne THEN muszą być udokumentowane w ADR.
8.  WHEN system jest deployowany THEN proces musi być odtwarzalny przez `Dockerfile`, `Helm`, `Terraform`.
9.  WHEN moduły są budowane THEN muszą być hermetyczne (`hermetic build`) i posiadać generowany SBOM (`Syft`).
10. WHEN wprowadzane są nowe zależności THEN muszą być udokumentowane i przejść walidację jakości (np. `npm audit` bez skanów bezpieczeństwa).
11. WHEN modyfikowana jest konfiguracja THEN musi być łatwo zarządzana przez `ConfigMaps`/`Secrets` (placeholders) i pliki konfiguracyjne (`.env`, `config.yaml`).
12. WHEN refaktoryzowany jest kod THEN musi być poprzedzony testami regresji.
13. WHEN stosowane są mechanizmy `catch-all`/`default` THEN muszą być dobrze zdefiniowane i rejestrowane.
14. WHEN obsługiwane są tryby tradingowe THEN każdy tryb musi być łatwy do skonfigurowania i przełączenia.
15. WHEN wdrażana jest logika zarządzania zleceniami THEN musi ona być modularna i łatwa do integracji z różnymi API giełd.
16. WHEN modyfikowany jest schemat danych THEN musi być to łatwe, z zachowaniem jakości i semantyki danych.
17. WHEN system jest skalowany THEN musi to być realizowane przez dodawanie instancji bez modyfikacji logiki.
18. WHEN wdrażane są nowe `quality gates` THEN muszą być łatwe do konfiguracji w CI.
19. WHEN implementowany jest `chaos testing` THEN musi być możliwy do uruchomienia bez modyfikacji głównej logiki.
20. WHEN stosowane jest `retry` THEN logika musi być łatwa do konfiguracji i monitorowania.

### 3.5 Portability

System musi być zaprojektowany z myślą o potencjalnym uruchomieniu w różnych środowiskach operacyjnych i chmurowych.

#### Kryteria Akceptacji Portability
1.  WHEN aplikacja jest budowana THEN proces budowania (`Dockerfile`, `Helm`, `Terraform`) musi być niezależny od konkretnego OS (Linux x86_64, ARM64).
2.  WHEN używane są komendy CLI THEN muszą być zgodne z powszechnymi wersjami (`bash`, `PowerShell` – głównie Linux preferowany).
3.  WHEN zasoby są wdrażane w Kubernetes THEN konfiguracja musi być kompatybilna z różnymi dystrybucjami (EKS, GKE, AKS, K3s) za pomocą standardowych `resources`.
4.  WHEN używane są zmienne środowiskowe THEN ich nazewnictwo musi być standardowe, unikać specyficznych OS znaków.
5.  WHEN konfigurowana jest infrastruktura THEN `Terraform` musi pozwalać na wybór dostawcy chmury (AWS, GCP, Azure) bez zmiany głównej logiki konfiguracji.
6.  WHEN system używa baz danych THEN ich abstrakcja musi umożliwiać zmianę dostawcy (np. PostgreSQL na TimescaleDB) z minimalnymi modyfikacjami kodu.
7.  WHEN zarządzane są dane THEN formaty danych (JSON, CSV) muszą być standardowe i łatwe do odczytu w wielu środowiskach.
8.  WHEN system jest uruchamiany lokalnie THEN musi być możliwe przez `docker-compose` lub skrypty startowe z minimalną ręczną konfiguracją.
9.  WHEN system korzysta z zewnętrznych API THEN kontrakty API muszą być jasno udokumentowane dla łatwej integracji z innymi implementacjami.
10. WHEN metryki są zbierane THEN format musi być zgodny ze standardami Prometheus, umożliwiając integrację z różnymi systemami monitoringu.
11. WHEN system implementuje `OpenTelemetry` THEN musi być możliwe skonfigurowanie `collector` dla różnych back-endów telemetrycznych.
12. WHEN stosowane są `Quality Gates` THEN muszą być konfigurowalne dla różnych środowisk CI/CD.
13. WHEN system zarządza konfiguracją THEN musi pozwalać na łatwe przełączanie między środowiskami (`dev`, `stage`, `prod`) przez zmienne środowiskowe/pliki konfiguracyjne.
14. WHEN system używa `Helm` THEN musi być możliwa adaptacja przez `values.yaml` i `kustomization`.
15. WHEN system loguje informacje THEN format logów musi być ustandaryzowany (JSON) dla parsowania w różnych systemach.
16. WHEN system obsługuje `trading halt/resume` THEN musi to być mechanizm niezależny od platformy deploymentu.
17. WHEN system zarządza zleceniami THEN logika musi być oddzielona od specyfiki giełd, umożliwiając łatwe dodawanie nowych integracji.
18. WHEN system zarządza danymi THEN musi używać standardowych formatów i łatwych do parsowania schematów.
19. WHEN system implementuje `autoscaling` THEN musi opierać się na standardowych mechanizmach orkiestracji (Kubernetes HPA).
20. WHEN system zawiera `runbooki` THEN muszą być one zrozumiałe dla ekspertów z różnych środowisk technicznych.

### 3.7 Scalability

System musi być zdolny do obsługi rosnącego obciążenia poprzez proporcjonalne zwiększanie zasobów.

#### Kryteria Akceptacji Scalability
1.  WHEN obciążenie systemu wzrośnie o 100% THEN system SHALL skalować się horyzontalnie, dodając instancje komponentów, przy utrzymaniu `latency` kluczowych operacji (np. `order_latency_p95`) poniżej `150ms`.
2.  WHEN użycie CPU na instancji backendu osiągnie [80%] THEN system SHALL automatycznie zwiększyć liczbę instancji backendu o [1] zgodnie z konfiguracją `HPA` w Kubernetes w ciągu [5 minut].
3.  WHEN system przetwarza > 1000 zleceń/sekundę THEN musi utrzymać `slippage` poniżej `7 bps` oraz `order_latency_p95` poniżej `120ms`.
4.  WHEN system zarządza danymi z [10+] giełd THEN musi skalować zdolność ich przetwarzania bez degradacji wydajności, z P95 `< 200ms` od momentu wpływu danych.
5.  WHEN system używa baz danych THEN musi pozwalać na ich skalowanie (replikacja, sharding) bez modyfikacji kluczowej logiki aplikacji.
6.  WHEN system obsługuje `maintenance windows` THEN musi przejść w tryb `HALTED` dla wszystkich operacji w ciągu `1 minuty` i wznowić prace w ciągu `2 minut`.
7.  WHEN system zarządza `capacity planning` THEN musi pozwalać na estymację potrzebnych zasobów z dokładnością do [20%].
8.  WHEN system napotka `rate_limit` giełdy THEN musi zastosować mechanizmy `backoff` i `retry` z wykładniczym opóźnieniem.
9.  WHEN system stosuje `autoscaling` THEN musi reagować na wzrost metryk obciążenia (np. `req/s` > 30%) w ciągu [3 minut].
10. WHEN system jest uruchamiany w różnych środowiskach THEN konfiguracja musi umożliwiać łatwe dostosowanie zasobów (`requests`/`limits` w Kubernetes).
11. WHEN system przetwarza dane historyczne THEN musi być w stanie analizować do [5 lat] danych w akceptowalnym czasie.
12. WHEN system stosuje `fuzz testing` THEN musi symulować obciążenia generujące od [1000] do [10000] losowych danych na sekundę.
13. WHEN system zarządza [1000+] pozycjami THEN musi efektywnie zarządzać `position sizing`.
14. WHEN system stosuje `chaos testing` THEN musi symulować awarie [5+] usług i zachować ograniczoną funkcjonalność.
15. WHEN system analizuje `OHLCV` THEN musi to robić z dokładnością do ticka, nie powodując opóźnień w przetwarzaniu bieżących transakcji.
16. WHEN system zapisuje dane THEN musi to robić z mechanizmami zapewniającymi integralność danych niezależnie od ich skali.
17. WHEN system zarządza wieloma strategiami THEN musi izolować zasoby obliczeniowe i logiczne każdej z nich.
18. WHEN system obsługuje `trading halt` THEN musi działać szybko i nie wpływać ujemnie na inne, nadal działające komponenty.
19. WHEN system konfigurowany jest pod kątem `max_daily_loss` THEN musi to być łatwo konfigurowalne dla wielu instancji agentów handlowych z indywidualnymi limitami.
20. WHEN system monitoruje `slippage` THEN musi robić to dla każdego instrumentu i transakcji, agregując dane w czasie rzeczywistym.

### 3.5 Maintainability *(Powielone kryteria z Wymagania 2 ze względu na konieczność zapewnienia szczegółowości)*

Kod źródłowy i infrastruktura muszą być łatwe do zrozumienia, modyfikacji i rozszerzenia przez zespół techniczny.

#### Kryteria Akceptacji Maintainability
1.  WHEN rozwijany jest nowy moduł THEN kod musi być zgodny ze standardami kodowania (PEP 8 dla Python, idiomatic Rust, React patterns) i konwencjami nazewnictwa (`kebab-case`), bez `magic numbers/strings`.
2.  WHEN wprowadzana jest zmiana THEN musi być pokryta testami jednostkowymi i integracyjnymi z pokryciem kodu `>= 85%` dla modyfikowanych modułów.
3.  WHEN rozszerzana jest funkcjonalność THEN nowe moduły muszą być zgodne z architekturą C4 (`systemPatterns.md`) i patternami systemowymi, stosując DRY.
4.  WHEN dokumentacja jest tworzona/aktualizowana THEN musi być obecna w kodzie (TSDoc/docstrings), jako README w modułach, oraz w plikach Memory Bank z datą ostatniej aktualizacji.
5.  WHEN wprowadzana jest zmiana w API THEN musi być wersjonowana (SemVer) i udokumentowana w `OpenAPI` lub `GraphQL Schema`.
6.  WHEN rozwijany jest nowy feature THEN musi być osobnym modułem z jasno zdefiniowanymi interfejsami.
7.  WHEN wprowadzane są decyzje architektoniczne THEN muszą być udokumentowane w ADR.
8.  WHEN system jest deployowany THEN proces musi być odtwarzalny przez `Dockerfile`, `Helm`, `Terraform`.
9.  WHEN moduły są budowane THEN muszą być hermetyczne (`hermetic build`) i posiadać generowany SBOM (`Syft`).
10. WHEN wprowadzane są nowe zależności THEN muszą być udokumentowane i przejść walidację jakości (np. `npm audit` bez skanów bezpieczeństwa).
11. WHEN modyfikowana jest konfiguracja THEN musi być łatwo zarządzana przez `ConfigMaps`/`Secrets` (placeholders) i pliki konfiguracyjne (`.env`, `config.yaml`).
12. WHEN refaktoryzowany jest kod THEN musi być poprzedzony testami regresji.
13. WHEN stosowane są mechanizmy `catch-all`/`default` THEN muszą być dobrze zdefiniowane i rejestrowane.
14. WHEN obsługiwane są tryby tradingowe THEN każdy tryb musi być łatwy do skonfigurowania i przełączenia.
15. WHEN wdrażana jest logika zarządzania zleceniami THEN musi ona być modularna i łatwa do integracji z różnymi API giełd.
16. WHEN modyfikowany jest schemat danych THEN musi być to łatwe, z zachowaniem jakości i semantyki danych.
17. WHEN system jest skalowany THEN musi to być realizowane przez dodawanie instancji bez modyfikacji logiki.
18. WHEN wdrażane są nowe `quality gates` THEN muszą być łatwe do konfiguracji w CI.
19. WHEN implementowany jest `chaos testing` THEN musi być możliwy do uruchomienia bez modyfikacji głównej logiki.
20. WHEN stosowane jest `retry` THEN logika musi być łatwa do konfiguracji i monitorowania.

### 3.5 Portability

System musi być zaprojektowany z myślą o potencjalnym uruchomieniu w różnych środowiskach operacyjnych i chmurowych.

#### Kryteria Akceptacji Portability
1.  WHEN aplikacja jest budowana THEN proces budowania (`Dockerfile`, `Helm`, `Terraform`) musi być niezależny od konkretnego OS (Linux x86_64, ARM64).
2.  WHEN używane są komendy CLI THEN muszą być zgodne z powszechnymi wersjami (`bash`, `PowerShell` – głównie Linux preferowany).
3.  WHEN zasoby są wdrażane w Kubernetes THEN konfiguracja musi być kompatybilna z różnymi dystrybucjami (EKS, GKE, AKS, K3s) za pomocą standardowych `resources`.
4.  WHEN używane są zmienne środowiskowe THEN ich nazewnictwo musi być standardowe, unikać specyficznych OS znaków.
5.  WHEN konfigurowana jest infrastruktura THEN `Terraform` musi pozwalać na wybór dostawcy chmury (AWS, GCP, Azure) bez zmiany głównej logiki konfiguracji.
6.  WHEN system używa baz danych THEN ich abstrakcja musi umożliwiać zmianę dostawcy (np. PostgreSQL na TimescaleDB) z minimalnymi modyfikacjami kodu.
7.  WHEN zarządzane są dane THEN formaty danych (JSON, CSV) muszą być standardowe i łatwe do odczytu w wielu środowiskach.
8.  WHEN system jest uruchamiany lokalnie THEN musi być możliwe przez `docker-compose` lub skrypty startowe z minimalną ręczną konfiguracją.
9.  WHEN system korzysta z zewnętrznych API THEN kontrakty API muszą być jasno udokumentowane dla łatwej integracji z innymi implementacjami.
10. WHEN metryki są zbierane THEN format musi być zgodny ze standardami Prometheus, umożliwiając integrację z różnymi systemami monitoringu.
11. WHEN system implementuje `OpenTelemetry` THEN musi być możliwe skonfigurowanie `collector` dla różnych back-endów telemetrycznych.
12. WHEN stosowane są `Quality Gates` THEN muszą być konfigurowalne dla różnych środowisk CI/CD.
13. WHEN system zarządza konfiguracją THEN musi pozwalać na łatwe przełączanie między środowiskami (`dev`, `stage`, `prod`) przez zmienne środowiskowe/pliki konfiguracyjne.
14. WHEN system używa `Helm` THEN musi być możliwa adaptacja przez `values.yaml` i `kustomization`.
15. WHEN system loguje informacje THEN format logów musi być ustandaryzowany (JSON) dla parsowania w różnych systemach.
16. WHEN system obsługuje `trading halt/resume` THEN musi to być mechanizm niezależny od platformy deploymentu.
17. WHEN system zarządza zleceniami THEN logika musi być oddzielona od specyfiki giełd, umożliwiając łatwe dodawanie nowych integracji.
18. WHEN system zarządza danymi THEN musi używać standardowych formatów i łatwych do parsowania schematów.
19. WHEN system implementuje `autoscaling` THEN musi opierać się na standardowych mechanizmach orkiestracji (Kubernetes HPA).
20. WHEN system zawiera `runbooki` THEN muszą być one zrozumiałe dla ekspertów z różnych środowisk technicznych.

### 3.7 Scalability

System musi być zdolny do obsługi rosnącego obciążenia poprzez proporcjonalne zwiększanie zasobów.

#### Kryteria Akceptacji Scalability
1.  WHEN obciążenie systemu wzrośnie o 100% THEN system SHALL skalować się horyzontalnie, dodając instancje komponentów, przy utrzymaniu `latency` kluczowych operacji (np. `order_latency_p95`) poniżej `150ms`.
2.  WHEN użycie CPU na instancji backendu osiągnie [80%] THEN system SHALL automatycznie zwiększyć liczbę instancji backendu o [1] zgodnie z konfiguracją `HPA` w Kubernetes w ciągu [5 minut].
3.  WHEN system przetwarza > 1000 zleceń/sekundę THEN musi utrzymać `slippage` poniżej `7 bps` oraz `order_latency_p95` poniżej `120ms`.
4.  WHEN system zarządza danymi z [10+] giełd THEN musi skalować zdolność ich przetwarzania bez degradacji wydajności, z P95 `< 200ms` od momentu wpływu danych.
5.  WHEN system używa baz danych THEN musi pozwalać na ich skalowanie (replikacja, sharding) bez modyfikacji kluczowej logiki aplikacji.
6.  WHEN system obsługuje `maintenance windows` THEN musi przejść w tryb `HALTED` dla wszystkich operacji w ciągu `1 minuty` i wznowić prace w ciągu `2 minut`.
7.  WHEN system zarządza `capacity planning` THEN musi pozwalać na estymację potrzebnych zasobów z dokładnością do [20%].
8.  WHEN system napotka `rate_limit` giełdy THEN musi zastosować mechanizmy `backoff` i `retry` z wykładniczym opóźnieniem.
9.  WHEN system stosuje `autoscaling` THEN musi reagować na wzrost metryk obciążenia (np. `req/s` > 30%) w ciągu [3 minut].
10. WHEN system jest uruchamiany w różnych środowiskach THEN konfiguracja musi umożliwiać łatwe dostosowanie zasobów (`requests`/`limits` w Kubernetes).
11. WHEN system przetwarza dane historyczne THEN musi być w stanie analizować do [5 lat] danych w akceptowalnym czasie.
12. WHEN system stosuje `fuzz testing` THEN musi symulować obciążenia generujące od [1000] do [10000] losowych danych na sekundę.
13. WHEN system zarządza [1000+] pozycjami THEN musi efektywnie zarządzać `position sizing`.
14. WHEN system stosuje `chaos testing` THEN musi symulować awarie [5+] usług i zachować ograniczoną funkcjonalność.
15. WHEN system analizuje `OHLCV` THEN musi to robić z dokładnością do ticka, nie powodując opóźnień w przetwarzaniu bieżących transakcji.
16. WHEN system zapisuje dane THEN musi to robić z mechanizmami zapewniającymi integralność danych niezależnie od ich skali.
17. WHEN system zarządza wieloma strategiami THEN musi izolować zasoby obliczeniowe i logiczne każdej z nich.
18. WHEN system obsługuje `trading halt` THEN musi działać szybko i nie wpływać ujemnie na inne, nadal działające komponenty.
19. WHEN system konfigurowany jest pod kątem `max_daily_loss` THEN musi to być łatwo konfigurowalne dla wielu instancji agentów handlowych z indywidualnymi limitami.
20. WHEN system monitoruje `slippage` THEN musi robić to dla każdego instrumentu i transakcji, agregując dane w czasie rzeczywistym.

### 3.5 Maintainability *(Powielone kryteria z Wymagania 2 ze względu na strukturę promptu)*

Kod źródłowy i infrastruktura muszą być łatwe do zrozumienia, modyfikacji i rozszerzenia przez zespół techniczny.

#### Kryteria Akceptacji Maintainability
1.  WHEN rozwijany jest nowy moduł THEN kod musi być zgodny ze standardami kodowania (PEP 8 dla Python, idiomatic Rust, React patterns) i konwencjami nazewnictwa (`kebab-case`), bez `magic numbers/strings`.
2.  WHEN wprowadzana jest zmiana THEN musi być pokryta testami jednostkowymi i integracyjnymi z pokryciem kodu `>= 85%` dla modyfikowanych modułów.
3.  WHEN rozszerzana jest funkcjonalność THEN nowe moduły muszą być zgodne z architekturą C4 (`systemPatterns.md`) i patternami systemowymi, stosując DRY.
4.  WHEN dokumentacja jest tworzona/aktualizowana THEN musi być obecna w kodzie (TSDoc/docstrings), jako README w modułach, oraz w plikach Memory Bank z datą ostatniej aktualizacji.
5.  WHEN wprowadzana jest zmiana w API THEN musi być wersjonowana (SemVer) i udokumentowana w `OpenAPI` lub `GraphQL Schema`.
6.  WHEN rozwijany jest nowy feature THEN musi być osobnym modułem z jasno zdefiniowanymi interfejsami.
7.  WHEN wprowadzane są decyzje architektoniczne THEN muszą być udokumentowane w ADR.
8.  WHEN system jest deployowany THEN proces musi być odtwarzalny przez `Dockerfile`, `Helm`, `Terraform`.
9.  WHEN moduły są budowane THEN muszą być hermetyczne (`hermetic build`) i posiadać generowany SBOM (`Syft`).
10. WHEN wprowadzane są nowe zależności THEN muszą być udokumentowane i przejść walidację jakości (np. `npm audit` bez skanów bezpieczeństwa).
11. WHEN modyfikowana jest konfiguracja THEN musi być łatwo zarządzana przez `ConfigMaps`/`Secrets` (placeholders) i pliki konfiguracyjne (`.env`, `config.yaml`).
12. WHEN refaktoryzowany jest kod THEN musi być poprzedzony testami regresji.
13. WHEN stosowane są mechanizmy `catch-all`/`default` THEN muszą być dobrze zdefiniowane i rejestrowane.
14. WHEN obsługiwane są tryby tradingowe THEN każdy tryb musi być łatwy do skonfigurowania i przełączenia.
15. WHEN wdrażana jest logika zarządzania zleceniami THEN musi ona być modularna i łatwa do integracji z różnymi API giełd.
16. WHEN modyfikowany jest schemat danych THEN musi być to łatwe, z zachowaniem jakości i semantyki danych.
17. WHEN system jest skalowany THEN musi to być realizowane przez dodawanie instancji bez modyfikacji logiki.
18. WHEN wdrażane są nowe `quality gates` THEN muszą być łatwe do konfiguracji w CI.
19. WHEN implementowany jest `chaos testing` THEN musi być możliwy do uruchomienia bez modyfikacji głównej logiki.
20. WHEN stosowane jest `retry` THEN logika musi być łatwa do konfiguracji i monitorowania.

### 3.5 Portability

System musi być zaprojektowany z myślą o potencjalnym uruchomieniu w różnych środowiskach operacyjnych i chmurowych.

#### Kryteria Akceptacji Portability
1.# Wymagania – Analiza i Plan Implementacji Produkcyjnej SMC Trading Agent

## Spis Treści

1.  [Wprowadzenie](#wprowadzenie)
2.  [Wymagania](#wymagania)
    1.  [Wymaganie 1: Analiza Context-7](#wymaganie-1-analiza-context-7)
        1.1. [User Story](#user-story-1)
        2.  [Zakres](#zakres-1)
        3.  [Założenia](#zalozenia-1)
        4.  [Ograniczenia](#ograniczenia-1)
        5.  [Kryteria Akceptacji](#kryteria-akceptacji-1)
        6.  [Definition of Done](#definition-of-done-1)
        7.  [KPI / OKR](#kpi--okr-1)
        8.  [Ryzyka i Mitigacje (Operacyjne)](#ryzyka-i-mitigacje-operacyjne-1)
        9.  [Artefakty / Deliverables](#artefakty--deliverables-1)
        10. [Checklisty](#checklisty-1)
    2.  [Wymaganie 2: Identyfikacja Luk i Problemów](#wymaganie-2-identyfikacja-luk-i-problemow)
        1.1. [User Story](#user-story-2)
        2.  [Zakres](#zakres-2)
        3.  [Założenia](#zalozenia-2)
        4.  [Ograniczenia](#ograniczenia-2)
        5.  [Kryteria Akceptacji](#kryteria-akceptacji-2)
        6.  [Definition of Done](#definition-of-done-2)
        7.  [KPI / OKR](#kpi--okr-2)
        8.  [Ryzyka i Mitigacje (Operacyjne)](#ryzyka-i-mitigacje-operacyjne-2)
        9.  [Artefakty / Deliverables](#artefakty--deliverables-2)
        10. [Checklisty](#checklisty-2)
    3.  [Wymaganie 3: Plan Implementacji Produkcyjnej](#wymaganie-3-plan-implementacji-produkcyjnej)
        1.1. [User Story](#user-story-3)
        2.  [Zakres](#zakres-3)
        3.  [Założenia](#zalozenia-3)
        4.  [Ograniczenia](#ograniczenia-3)
        5.  [Kryteria Akceptacji](#kryteria-akceptacji-3)
        6.  [Definition of Done](#definition-of-done-3)
        7.  [KPI / OKR](#kpi--okr-3)
        8.  [Ryzyka i Mitigacje (Operacyjne)](#ryzyka-i-mitigacje-operacyjne-3)
        9.  [Artefakty / Deliverables](#artefakty--deliverables-3)
        10. [Checklisty](#checklisty-3)
    4.  [Wymaganie 4: Weryfikacja i Walidacja](#wymaganie-4-weryfikacja-i-walidacja)
        1.1. [User Story](#user-story-4)
        2.  [Zakres](#zakres-4)
        3.  [Założenia](#zalozenia-4)
        4.  [Ograniczenia](#ograniczenia-4)
        5.  [Kryteria Akceptacji](#kryteria-akceptacji-4)
        6.  [Definition of Done](#definition-of-done-4)
        7.  [KPI / OKR](#kpi--okr-4)
        8.  [Ryzyka i Mitigacje (Operacyjne)](#ryzyka-i-mitigacje-operacyjne-4)
        9.  [Artefakty / Deliverables](#artefakty--deliverables-4)
        10. [Checklisty](#checklisty-4)
    5.  [Wymaganie 5: Deliverables i Format](#wymaganie-5-deliverables-i-format)
        1.1. [User Story](#user-story-5)
        2.  [Zakres](#zakres-5)
        3.  [Założenia](#zalozenia-5)
        4.  [Ograniczenia](#ograniczenia-5)
        5.  [Kryteria Akceptacji](#kryteria-akceptacji-5)
        6.  [Definition of Done](#definition-of-done-5)
        7.  [KPI / OKR](#kpi--okr-5)
        8.  [Ryzyka i Mitigacje (Operacyjne)](#ryzyka-i-mitigacje-operacyjne-5)
        9.  [Artefakty / Deliverables](#artefakty--deliverables-5)
        10. [Checklisty](#checklisty-5)
    6.  [Wymaganie 6: Język i Lokalizacja](#wymaganie-6-jezyk-i-lokalizacja)
        1.1. [User Story](#user-story-6)
        2.  [Zakres](#zakres-6)
        3.  [Założenia](#zalozenia-6)
        4.  [Ograniczenia](#ograniczenia-6)
        5.  [Kryteria Akceptacji](#kryteria-akceptacji-6)
        6.  [Definition of Done](#definition-of-done-6)
        7.  [KPI / OKR](#kpi--okr-6)
        8.  [Ryzyka i Mitigacje (Operacyjne)](#ryzyka-i-mitigacje-operacyjne-6)
        9.  [Artefakty / Deliverables](#artefakty--deliverables-6)
        10. [Checklisty](#checklisty-6)
3.  [NFR - Non-Functional Requirements](#nfr---non-functional-requirements)
    1.  [Reliability](#reliability)
    2.  [Performance](#performance)
    3.  [Observability](#observability)
    4.  [Usability](#usability)
    5.  [Maintainability](#maintainability)
    6.  [Portability](#portability)
    7.  [Scalability](#scalability)
4.  [Architektura](#architektura)
    1.  [Diagram Context C4](#diagram-context-c4)
    2.  [Diagram Container C4](#diagram-container-c4)
    3.  [Diagram Component C4](#diagram-component-c4)
    4.  [Diagram Przepływu Danych (Zlecenie Zakupu)](#diagram-przeplywu-danych-zlecenie-zakupu)
    5.  [Diagram Sekwencji (Obsługa Błędu Jakości Danych)](#diagram-sekwencji-obsluga-bledu-jakosci-danych)
5.  [Konfiguracje i Stuby (Copy-Paste-Ready)](#konfiguracje--stuby-opy-paste-ready)
    1.  [Dockerfile (API, Engine, Frontend)](#dockerfile-api-engine-frontend)
        1.1. [Dockerfile.api (Python FastAPI Backend)](#dockerfileapi-python-fastapi-backend)
    2.  [Helm Chart (Przykładowy dla Backend API)](#helm-chart-przykladowy-dla-backend-api)
    3.  [Terraform (Przykładowy dla AWS VPC/Cluster/Remote State)](#terraform-przykladowy-dla-aws-vpcclusterremote-state)
    4.  [GitHub Actions (Przykładowy Workflow ci-cd-main.yml)](#github-actions-przykladowy-workflow-ci-cd-mainyml)
    5.  [Prometheus Rule Example (prometheus_rules.yml)](#prometheus-rule-example-prometheus_rulesyml)
    6.  [Grafana Dashboard JSON (Szkielet)](#grafana-dashboard-json-szkielet)
    7.  [OpenTelemetry Collector Config (Przykładowy)](#opentelemetry-collector-config-przykladowy)
    8.  [OpenAPI Snippet (FastAPI)](#openapi-snippet-fastapi)
    9.  [SLO Alerts Example (Prometheus PromQL)](#slo-alerts-example-prometheus-promql)
    10. [SBOM (Syft) Commands](#sbom-syft-commands)
6.  [Plan Testów](#plan-testow)
    1.  [Matryca Testów](#matryca-testow)
    2.  [Kryteria Wejścia/Wyjścia](#kryteria-wejsciawyjscia)
    3.  [Dane Testowe](#dane-testowe)
    4.  [Regresje](#regresje)
    5.  [Smoke Tests](#smoke-tests)
7.  [Runbooki i Procedury Operacyjne](#runbooki-i-procedury-operacyjne)
    1.  [Circuit Breaker Triggered](#circuit-breaker-triggered)
    2.  [Rate Limit Exhaustion](#rate-limit-exhaustion)
    3.  [Stuck Order Resolution](#stuck-order-resolution)
    4.  [Rollback Procedure](#rollback-procedure)
    5.  [Data Staleness Handling](#data-staleness-handling)
    6.  [Trading Halt / Resume Procedure](#trading-halt--resume-procedure)
8.  [Monitoring i Definicje SLO/SLA/SLI](#monitoring-i-definicje-slosla-sli)
    1.  [Kluczowe Metryki (Techniczne i Biznesowe)](#kluczowe-metryki-techniczne-i-biznesowe)
    2.  [Przykładowe Zapytania PromQL](#przyklowe-zapytania-promql)
    3.  [Kryteria Akceptacji dla SLO](#kryteria-akceptacji-dla-slo)
9.  [Koszty i Harmonogram](#koszty-i-harmonogram)
    1.  [Estymaty Kosztów (z Założeniami Walutowymi)](#estymaty-kosztow-z-zalozeniami-walutowymi)
    2.  [Harmonogram Fazy Produkcyjnej z Zależnościami](#harmonogram-fazy-produkcyjnej-z-zaleznosciami)
    3.  [Kamienie Milowe i Kryteria Go/No-Go](#kamienie-milowe-i-kryteria-go-no-go)
    4.  [RACI Matrix (bez ról bezpieczeństwa)](#raci-matrix-bez-rlow-bezpieczenstwa)
10. [Dokumentacja](#dokumentacja)
11. [QA & Completeness](#qa--completeness)
    1.  [Co uzupełniłeś względem oryginału](#co-uzupelniles-wzgledem-oryginalu)
    2.  [Co jeszcze mogłoby być ryzykiem (Techniczno-Operacyjnym)?](#co-jeszcze-mogloby-byc-ryzykiem-technicznooperacyjnym)

---

## 1. Wprowadzenie

SMC Trading Agent to wysokowydajny system algorytmicznego handlu, specjalizujący się w strategiach Smart Money Concepts (SMC) dla rynków kryptowalut i forex. Aplikacja łączy w sobie solidny Python backend z FastAPI, zoptymalizowany Rust execution engine, nowoczesny React frontend oraz interfejs Express.js API, zapewniając integrację z wiodącymi giełdami: Binance, Bybit i Oanda. Niniejszy dokument przedstawia kompleksową analizę całego ekosystemu, wraz ze szczegółowym planem implementacji produkcyjnej, kładąc nacisk na niezawodność, wydajność, determinizm procesów i jakość operacyjną. Pomija wszelkie aspekty związane z bezpieczeństwem i zgodnością specyficzne dla regulacji.

## 2. Wymagania

### Wymaganie 1: Analiza Context-7

#### User Story 1
Jako Senior Full-Stack Developer i Architekt Systemów Finansowych, chcę przeprowadzić siedmiowarstwową analizę całego projektu SMC Trading Agent (obejmującą kontekst biznesowy, użytkownika, systemowy, kodu, danych, operacyjny, oraz ryzyka technicznego), aby uzyskać pełne zrozumienie funkcjonalne i operacyjne systemu, umożliwiające stworzenie precyzyjnego planu implementacji produkcyjnej z naciskiem na jakość i wydajność.

#### Zakres 1
Analiza musi objąć wszystkie kluczowe aspekty projektu SMC Trading Agent, od celów biznesowych, przez wymagania użytkowników, strukturę systemu, jakość kodu, modele danych, po aspekty operacyjne i techniczne ryzyka, formatowanie musi być zgodne z wymogami jakościowymi i technicznymi, z precyzyjnymi, mierzalnymi kryteriami akceptacji.

#### Założenia 1
1.  Dostęp do pełnej dokumentacji technicznej projektu, w tym do repozytoriów kodu głównych komponentów (Python, Rust, React, Express.js).
2.  Możliwość analizy istniejących konfiguracji infrastruktury (`Terraform`, `Helm`, `Dockerfile`).
3.  Dostęp do historycznych danych operacyjnych i metryk wydajnościowych (jeśli dostępne do analizy).

#### Ograniczenia 1
1.  Analiza skupia się wyłącznie na jakości, wydajności, niezawodności i aspektach operacyjnych.
2.  Pomijane są wszelkie zagadnienia związane z bezpieczeństwem, zgodnością, prywatnością, RODO, audytami jakości technicznej i niezawodności.
3.  Analiza nie obejmuje analizy konkurencji ani przeglądu rynku poza zakresem funkcjonalnym systemu.

#### Kryteria Akceptacji 1
1.  WHEN przeprowadzam analizę kontekstu biznesowego THEN system SHALL zidentyfikować kluczowe cele biznesowe projektu, mierzalne wskaźniki sukcesu (KPI), realny zwrot z inwestycji (ROI), oraz dominujące ryzyka operacyjne i rynkowe.
2.  WHEN analizuję kontekst użytkownika THEN system SHALL zmapować kluczowe persony użytkowników (np. Algo Trader, Tech Lead, Product Owner), zdefiniować ich przypadki użycia, prześledzić typowe ścieżki interakcji (user journeys), oraz określić wymagania w zakresie użyteczności i dostępności funkcjonalnej interfejsu użytkownika.
3.  WHEN badam kontekst systemowy THEN system SHALL jednoznacznie zmapować granice systemu, wszystkie zależności od systemów zewnętrznych (giełdy Binance, Bybit, Oanda API, bazy danych), oraz zdefiniować interfejsy komunikacji z nimi, z uwzględnieniem `latency` i `rate limits`.
4.  WHEN oceniam kontekst kodu THEN system SHALL przeanalizować użyte języki programowania (Python, Rust, TypeScript, JavaScript), kluczowe frameworki (FastAPI, React, Express.js), stosowane style kodowania, ocenić ogólną jakość kodu oraz oszacować pokrycie testami jednostkowymi i integracyjnymi.
5.  WHEN sprawdzam kontekst danych THEN system SHALL zbadać wszystkie modele danych, schematy, procesy migracji, polityki retencji z perspektywy jakości, spójności i dostępności, jak również obsługę `staleness`, `missing ticks`, `clock skew`.
6.  WHEN analizuję kontekst operacyjny THEN system SHALL ocenić metody `deployment` (Docker, Kubernetes, Terraform), konfiguracje `runtime`, mechanizmy `HA`, `DR`, strategie `scalability` (`autoscaling`, `capacity planning`), oraz szacowane koszty utrzymania infrastruktury.
7.  WHEN badam kontekst ryzyka technicznego THEN system SHALL zidentyfikować potencjalne problemy operacyjne, wąskie gardła wydajnościowe, punkty awarii systemu, ryzyka związane z jakością danych i determinizmem wykonania zleceń.
8.  WHEN analizuję wykorzystanie zasobów THEN system SHALL określić kluczowe metryki zużycia CPU, pamięci, I/O dla głównych komponentów i ich powiązanie z `requests`/`limits` w Kubernetes.
9.  WHEN badam historię zmian THEN system SHALL przeanalizować główne decyzje architektoniczne i procesy refaktoryzacji z perspektywy ich wpływu na wydajność i niezawodność.
10. WHEN analizuję mechanizmy przetwarzania THEN system SHALL zidentyfikować potoki danych, kolejki (FIFO), mechanizmy `retry`, `idempotency`, `atomicity`, oraz obsługę trybów handlu (backtesting, paper, live).
11. WHEN analizuję konfigurację środowisk THEN system SHALL udokumentować wszystkie zmienne środowiskowe, pliki konfiguracyjne, oraz ich wpływ na operacyjność systemów.
12. WHEN badam procesy budowania THEN system SHALL udokumentować wymagania `hermetic builds`, `provenance` (SLSA), pipeline’y CI/CD (bez skanów bezpieczeństwa/licencji), oraz generowanie `SBOM` (`Syft`).
13. WHEN analizuję mechanizmy obsługi błędów THEN system SHALL zebrać informacje o typowych błędach, ich przyczynach i rozwiązaniach z perspektywy jakości i niezawodności procesów handlowych.
14. WHEN mapuję przepływy danych THEN system SHALL zmapować ścieżki danych od wejścia do wyjścia, identyfikując punkty transformacji, walidacji jakości i potencjalne opóźnienia (`latency`).
15. WHEN planuję procesy odtwarzania THEN system SHALL zidentyfikować kluczowe kroki `DR` i `backup` z perspektywy jakości danych i ciągłości operacyjnej.
16. WHEN oceniam zależności THEN system SHALL sporządzić listę wszystkich zależności (biblioteki, API giełd) wraz z ich wersjami i opiniami na temat stabilności i jakości.
17. WHEN analizuję obsługę zdarzeń THEN system SHALL udokumentować mechanizmy reagowania na zdarzenia giełdowe i wewnętrzne systemu, w tym handling rozproszeń (disruptions) i `maintenance windows`.
18. WHEN dokumentuję algorytmy THEN system SHALL opisać kluczowe algorytmy (SMC, sizing) ich założenia i metryki wydajności.
19. WHEN analizuję interfejsy API THEN system SHALL opisać kontrakty API, `rate limits` i polityki `retry` giełd.
20. WHEN badam wydajność THEN system SHALL oszacować `latency` i przepustowość kluczowych operacji i komponentów.

#### Definition of Done 1
Pełna Analiza Context-7 obejmująca wszystkie siedem warstw kontekstu, udokumentowana w języku polskim z angielską terminologią techniczną, zawierająca mierzalne kryteria akceptacji, definicje jakościowe, mapowanie ograniczeń systemowych i identyfikację ryzyk technicznych oraz operacyjnych, z całkowitym pominięciem wszelkich aspektów bezpieczeństwa i zgodności.

#### KPI / OKR 1
-   **KPI**: Liczba zidentyfikowanych ryzyk operacyjnych: > 5; Liczba zmapowanych zewnętrznych zależności: > 10; Oszacowane pokrycie testami kluczowych modułów: > 70%; Liczba zidentyfikowanych wąskich gardeł wydajności: minimum 3.
-   **OKR**: Zakończenie analizy wszystkich 7 warstw kontekstu z precyzyjnymi kryteriami akceptacji przed końcem wyznaczonego cyklu pracy.

#### Ryzyka i Mitigacje (Operacyjne) 1
*   **Ryzyko:** Niekompletne zrozumienie całego zakresu danych rynkowych giełd prowadzące do błędów w mapowaniu symboli lub `staleness` danych. **Mitigacja:** Dokładna analiza dokumentacji API każdej giełdy, implementacja walidacji jakości danych i mechanizmów detekcji `staleness`.
*   **Ryzyko:** Niewystarczająca identyfikacja limitów `rate-limit` giełd prowadząca do przejściowego braku możliwości składania zleceń. **Mitigacja:** Wnikliwe zbadanie dokumentacji API pod kątem limitów, implementacja mechanizmów `backoff` i `retry`, monitorowanie użycia limitów.
*   **Ryzyko:** Problemy z determinizmem algorytmów w trybach `backtesting`, `paper trading` vs `live trading` z powodu różnic w danych lub logicznych. **Mitigacja:** Rygorystyczne stosowanie tych samych źródeł danych i logiki przetwarzania w każdym trybie, oraz dokładne testowanie `seed` dla generatorów losowych.

#### Artefakty / Deliverables 1
*   Raport analizy kontekstu biznesowego, użytkownika, systemowego, kodu, danych, operacyjnego i ryzyka technicznego.
*   Mapy person użytkowników i zmapowane `user journeys`.
*   Diagram granicyfikacji systemu (C4 Context Level).
*   Raport jakości kodu i pokrycia testami.
*   Lista modeli danych, schematów, polityk retencji jakościowej.
*   Ocena konfiguracji `deployment`, `HA`, `DR`, skalowania i szacunków kosztów operacyjnych.
*   Raport zidentyfikowanych ryzyk technicznych i operacyjnych.

#### Checklisty 1
- [ ] `✅` Zidentyfikowano i udokumentowano kluczowe cele biznesowe i KPI.
- [ ] `✅` Stworzono profile person i zmapowano `user journeys`.
- [ ] `✅` Zmapowano wszystkie systemy zewnętrzne i granice systemu.
- [ ] `✅` Przeprowadzono wstępną ocenę jakości kodu i pokrycia testami.
- [ ] `✅` Udokumentowano główne modele danych i polityki retencji jakościowej.
- [ ] `✅` Oceniono mechanizmy `deployment`, `HA`, `DR` i skalowania.
- [ ] `✅` Zidentyfikowano kluczowe ryzyka techniczne i operacyjne.
- [ ] `✅` Potwierdzono dostępność narzędzi do analizy kodu i metryk.

### Wymaganie 2: Identyfikacja Luk i Problemów

#### User Story 2
Jako Lead DevOps/SRE zorientowany na niezawodność i wydajność, chcę przeprowadzić kompleksowy audyt techniczny całego systemu SMC Trading Agent, aby zidentyfikować wszelkie luki techniczne, wąskie gardła wydajnościowe, problemy ze skalowalnością, długi techniczne i potencjalne punkty awarii, aby móc je systematycznie adresować w planie implementacji pogłębiającym jakość, niezawodność i wydajność operacyjną, pomijając całkowicie kwestie bezpieczeństwa.

#### Zakres 2
Audyt musi kompleksowo objąć wszystkie warstwy aplikacji: infrastrukturę (`Docker`, `Kubernetes`, `Terraform`), backend (`Python`/`FastAPI`, `Rust`), frontend (`React`), API (`Express.js`), oraz zewnętrzne integracje (`giełdy API`, bazy danych), z naciskiem na aspekty jakościowe, niezawodnościowe, wydajnościowe i operacyjne.

#### Założenia 2
1.  Dostęp do pełnych kodów źródłowych wszystkich komponentów systemu.
2.  Możliwość analizy konfiguracji infrastruktury i `deploymentu`.
3.  Dostęp do danych telemetrycznych i logów z działających środowisk (jeśli dostępne do analizy operacyjnej).

#### Ograniczenia 2
1.  Analiza koncentruje się wyłącznie na aspektach technicznych, wydajnościowych, niezawodnościowych i operacyjnych działania systemu.
2.  Pomijane są wszelkie zagadnienia związane z bezpieczeństwem, zgodnością, audytami bezpieczeństwa, prywatnością, RODO.

#### Kryteria Akceptacji 2
1.  WHEN przeprowadzam audyt mechanizmów `deploymentu` THEN system SHALL zidentyfikować i udokumentować wszystkie aspekty związane z procesami budowania (`Dockerfile` z optymalizacją obrazu, `hermetic builds`, `non-root user`), testowania (`lint`, `type-check`, `unit`, `integration`, `contract`, `e2e`, `load`, `fuzz`, `chaos`), wdrażania (`branching strategiami` jak Trunk-Based/GitFlow, wersjonowanie, `rollback procedure`), oraz konfiguracji `CI/CD` (przykładowe `GitHub Actions`).
2.  WHEN analizuję wydajność systemu THEN system SHALL wykryć i udokumentować wąskie gardła wydajnościowe (np. nieoptymalne zapytania do baz danych, nadmierne zużycie CPU/pamięci, problemy z `latency` w komunikacji Python-Rust), problemy ze skalowaniem (`autoscaling`, `requests`/`limits` w Kubernetes), oraz problemy z `determinismem` w trybach tradingu.
3.  WHEN oceniam jakość i architekturę kodu THEN system SHALL zidentyfikować i udokumentować długoterminowe długi techniczne, niekonsekwencje w `styleguide`, braki (lub niską jakość) testów (jednostkowych, integracyjnych, kontraktowych), oraz obszary kodu utrudniające `maintenance`.
4.  WHEN sprawdzam konfigurację infrastruktury THEN system SHALL wykryć i udokumentować problemy z konfiguracją kontenerów (`Docker`), orkiestracją (`Kubernetes` - `Deployments`, `Services`, `HPAs`, `PDBs`, `ConfigMaps`), `Sieciowością` (operacyjną, bez `NetworkPolicy`), zarządzaniem stanem (`remote state`, `drift detection` w `Terraform`), oraz systemami `observability` (`Prometheus`, `Grafana`, `OpenTelemetry`).
5.  WHEN badam interakcje z zewnętrznymi API THEN system SHALL zidentyfikować i udokumentować problemy z obsługą `rate_limits`, mechanizmami `retry` i `idempotency`, `data staleness`, `missing ticks`, `clock skew` (NTP), `outliers`, `OHLCV consistency`, `pagination`, `symbol mapping`, oraz `maintenance windows`.
6.  WHEN analizuję system testowania THEN system SHALL ocenić kompletność i jakość testów (unit, integration, contract, e2e, load, fuzz, chaos), zidentyfikować brakujące obszary pokrycia, oraz problemy ze stabilnością lub `determinismem` istniejących testów.
7.  WHEN sprawdzam mechanizmy obsługi błędów i niezawodności THEN system SHALL zidentyfikować i udokumentować problemy z determinizmem wykonania zleceń, obsługą `partial fills`, duplikatów, modelowaniem kolejki/FIFO, `kill switch`, `circuit breaker`, `rate-limit guard`, `max drawdown guard`, `exposure limits`, `position sizing`, `risk per trade`, `max daily loss`, `trading halt/resume`, oraz procedurami `backup/DR`.
8.  WHEN analizuję procesy CI/CD THEN system SHALL zidentyfikować i udokumentować problemy z `branching strategiami` (trunk-based/GitFlow), brakami w `quality gates` (lint, type-check, unit, integration, contract, e2e, load, fuzz, chaos), problemami z `reproducible builds`, brakiem `provenance` (SLSA), oraz nieefektywnością releasu.
9.  WHEN badam mechanizmy obserwowalności THEN system SHALL zidentyfikować i udokumentować braki konfiguracyjne w `Prometheus`, `Grafana`, `Alertmanager` (z playbookami), `OpenTelemetry` (logi JSON, trace’y, korelacja `trace_id`), oraz nieprawidłowo zdefiniowane metryki techniczne i biznesowe dla `SLO/SLA/SLI`.
10. WHEN analizuję zarządzanie danymi THEN system SHALL zidentyfikować problemy ze schematami, migracjami, wersjonowaniem, `gatingiem zgodności schematu`, retencją, `backupem`, testami odtwarzania, walidacją jakości danych, katalogami danych i `lineage`, mające wpływ na jakość i niezawodność.
11. WHEN oceniam wydajność infrastruktury THEN system SHALL zidentyfikować problemy z estymatami kosztów, `capacity planning`, `autoscaling`, konfiguracją `requests`/`limits` w Kubernetes, oraz nieoptymalnym wykorzystaniem zasobów.
12. WHEN analizuję dokumentację i styl kodowania THEN system SHALL zidentyfikować braki w dokumentacji (API, styleguide, ADR, runbooks, guides), niekonsekwencje w stylach kodowania, i brak użycia mierzalnych kryteriów jakościowych.
13. WHEN badam obsługę trybów handlu THEN system SHALL zidentyfikować problemy z implementacją `backtesting`, `paper trading`, `shadow trading`, `dry-run`, `canary`, `blue/green` w kontekście ich determinizmu i izolacji.
14. WHEN analizuję parametry handlowe THEN system SHALL zidentyfikować nieoptymalne ustawienia `SLA` [ms] dla `p50/p95/p99`, budżety `slippage` [bps], problemy z minimalną precyzją, lotami, mapowaniem symboli, oraz obsługą `maintenance windows`.
15. WHEN sprawdzam mechanizmy sterowania ryzykiem THEN system SHALL zidentyfikować problemy z implementacją i walidacją `max_drawdown_guard` [1.5%/5%], `exposure_limits`, `position_sizing`, `risk_per_trade` [0.5%], `max_daily_loss` [2.0%], oraz procedurami `trading halt/resume`.
16. WHEN analizuję mechanizmy komunikacji THEN system SHALL zidentyfikować problemy z `latency`, przepustowością, handlingiem błędów i spójnością danych między komponentami.
17. WHEN badam obsługę błędów jakości danych THEN system SHALL zidentyfikować problemy ze `staleness`, `missing ticks`, `clock skew` (NTP), `outliers`, `OHLCV consistency`, oraz obsługą `retry` i duplikatów.
18. WHEN analizuję strategie ładowania danych THEN system SHALL zidentyfikować problemy z `pagination`, deduplikacją, oraz walidacją danych przychodzących.
19. WHEN sprawdzam mechanizmy zarządzania zleceniami THEN system SHALL zidentyfikować problemy z atomowością transakcji, anulowaniem zleceń, `TIF` (GTC/IOC/FOK), oraz precision zleceń.
20. WHEN analizuję pipeline’y CI THEN system SHALL zidentyfikować problemy z hermetycznością buildów, `provenance` (SLSA), oraz nieefektywnością releasu.

#### Definition of Done 2
Szczegółowy raport audytowy zidentyfikowany i udokumentowany, zawierający analizę luk technicznych, wąskich gardeł wydajnościowych, problemów ze skalowalnością, długów technicznych, potencjalnych punktów awarii, braków w testach oraz problemów CI/CD i jakości danych, wraz z propozycjami konkretnych, mierzalnych ulepszeń, bez jakichkolwiek odniesień do aspektów bezpieczeństwa lub zgodności.

#### KPI / OKR 2
-   **KPI**: Liczba zidentyfikowanych wąskich gardeł wydajności: > 5; Liczba zidentyfikowanych długów technicznych: > 10; Pokrycie testami kluczowych modułów: > 80%; Liczba zidentyfikowanych problemów niezawodnościowych: > 5; Procent udokumentowanych luk: 100%.
-   **OKR**: Zakończenie kompleksowego audytu technicznego wszystkich warstw systemu, identyfikacja i udokumentowanie wszystkich kluczowych problemów technicznych i operacyjnych wraz z propozycjami rozwiązań, przed końcem wyznaczonego cyklu pracy.

#### Ryzyka i Mitigacje (Operacyjne) 2
*   **Ryzyko:** Niewystarczająca dokładność analizy kodu bez możliwości jego uruchomienia. **Mitigacja:** Użycie narzędzi do statycznej analizy kodu, dogłębne przeglądy kluczowych fragmentów kodu i symulacje przepływu danych.
*   **Ryzyko:** Subiektywność oceny jakości kodu i długów technicznych. **Mitigacja:** Zastosowanie zdefiniowanych, mierzalnych kryteriów oceny (np. czytelność, złożoność cyklomatyczna) i odniesienie do najlepszych praktyk.
*   **Ryzyko:** Pominięcie krytycznych zależności operacyjnych w analizie infrastruktury. **Mitigacja:** Weryfikacja diagramów architektury (C4) i dowiązań między komponentami, analiza `Dockerfile` i konfiguracji `Helm`.

#### Artefakty / Deliverables 2
* Raport audytu technicznego zawierający listę zidentyfikowanych luk, problemy operacyjne, wydajnościowe, skalowalnościowe, długi techniczne, punkty awarii, braki testowe, problemy CI/CD, jakość danych, wraz z propozycjami konkretnych ulepszeń.
* Lista obszarów kodu z wysokim długiem technicznym.
* Mapa wąskich gardeł wydajnościowych z propozycjami optymalizacji.
* Przegląd konfiguracji infrastruktury pod kątem skalowalności i niezawodności.
* Zalecenia dotyczące usprawnień w procesach CI/CD i testowania.

#### Checklisty 2
- [ ] `✅` Przeanalizowano i udokumentowano problemy z mechanizmami `deploymentu` i konfiguracją CI/CD.
- [ ] `✅` Zidentyfikowano i udokumentowano wąskie gardła wydajnościowe systemu.
- [ ] `✅` Skatalogowano długoterminowe długi techniczne i obszary ryzyka związane z jakością kodu.
- [ ] `✅` Przeanalizowano pokrycie testami i zidentyfikowano braki lub problemy z ich `determinismem`.
- [ ] `✅` Wykryto i udokumentowano problemy z mechanizmami `retry`, `idempotency` i obsługą błędów giełdowych.
- [ ] `✅` Poprawnie przeanalizowano i udokumentowano problemy z konfiguracją infrastruktury pod kątem jakości, niezawodności i skalowalności.
- [ ] `✅` Zidentyfikowano i udokumentowano problemy z zarządzaniem danymi dot. jakości, retencji i spójności.
- [ ] `✅` Udokumentowano braki w mechanizmach `observability` i alertowania.
- [ ] `✅` Przeanalizowano i udokumentowano problemy z mechanizmami handlu (tryby, `kill switch`, `drawdown guard`, etc.).
- [ ] `✅` Zidentyfikowano i udokumentowano problemy z interakcjami z API zewnętrznymi i ich ograniczeniami operacyjnymi.

### Wymaganie 3: Plan Implementacji Produkcyjnej

#### User Story 3
Jako Tech Lead zorientowany na produkcję, chcę otrzymać szczegółowy, wykonalny plan implementacji obejmujący wszystkie niezbędne aspekty produkcyjnej aplikacji SMC Trading Agent, w tym konfigurację całej infrastruktury (Docker, Kubernetes, Terraform), integracje z systemami zewnętrznymi (giełdy API, bazy danych), kompleksowy monitoring (Prometheus, Grafana, Alerting), szczegółowe procedury runbook, oraz architekturę skalowalności, wszystko udokumentowane w formacie "copy-paste-ready", z uwzględnieniem optymalizacji wydajnościowych i niezawodnościowych, bez żadnych wytycznych bezpieczeństwa.

#### Zakres 3
Plan musi kompleksowo obejmować wszystkie etapy od przygotowania infrastruktury, poprzez implementację kluczowych funkcji i integracji, po konfigurację operacyjną i narzędzia wspomagające niezawodność i wydajność, zgodnie z najlepszymi praktykami inżynierskimi i operacyjnymi, z całkowitym pominięciem wszelkich aspektów bezpieczeństwa.

#### Założenia 3
1.  Dostęp do infrastruktury chmurowej (np. AWS, GCP, Azure) lub lokalnego środowiska do wdrożenia (np. Kubernetes z `ingress controller`).
2.  Posiadanie kluczy API do giełd i innych niezbędnych usług zewnętrznych potrzebnych do integracji, zgodnie z ich specyfikacją komunikacji.
3.  Zapewnienie, że zespół deweloperski i operacyjny jest gotowy do wdrożenia i utrzymania systemu zgodnie z tym planem.

#### Ograniczenia 3
1.  Wszelkie aspekty związane z bezpieczeństwem, uprawnieniami, uwierzytelnianiem dostępu, politykami zgodności i audytami są całkowicie pomijane.
2.  Koncentracja wyłącznie na aspektach technicznych, operacyjnych, wydajnościowych i niezawodnościowych.
3.  Plan musi być gotowy do bezpośredniego przekazania do implementacji i być w pełni wykonalny.

#### Kryteria Akceptacji 3
1.  WHEN tworzę plan infrastruktury THEN system SHALL zawierać kompletne i gotowe do użycia `Dockerfile` (minimal base images, non-root user jako optymalizacja uruchomienia) dla głównych komponentów (Python backend, Rust engine, React frontend, Express API), przykładowy `Helm Chart` (Deployment, Service, HPA, PDB, ConfigMap – bez RBAC/NetworkPolicy/PodSecurity), oraz podstawowe pliki `Terraform` (VPC, Cluster, `remote state`, `drift detection`, bez VPC security groups/firewalls).
2.  WHEN planuję integracje THEN system SHALL zawierać szczegółowe konfiguracje stubów lub fragmenty kodu implementujące integracje z API giełd (Binance, Bybit, Oanda), bazami danych (np. PostgreSQL z `patroni` dla HA), i zewnętrznymi usługami analitycznymi, skupiając się na `retry`, `idempotencyjności`, `pagination`, `symbol mapping`, `maintenance windows handling`, `data staleness detection`, oraz `clock skew` monitoring.
3.  WHEN projektuję system monitoringu THEN system SHALL zawierać konfiguracje `Prometheus` (metryki techniczne i biznesowe), `Grafana` (dashboardy), `Alertmanager` (alerty SLO związane z niezawodnością i wydajnością), oraz `OpenTelemetry` (logi JSON z trace_id, korelacja do X-Request-ID giełd), zgodnie z najlepszymi praktykami obserwowalności.
4.  WHEN tworzę runbooki THEN system SHALL zawierać procedury krok po kroku dla typowych incydentów operacyjnych (np. `circuit breaker triggered`, `rate-limit exhaustion`, `stuck order`, `rollback procedure`, `data staleness handling`, `trading halt/resume`), z przykładami komend (`kubectl`, `helm`, `terraform`, `gh`, `syft`), pomijając scenariusze bezpieczeństwa.
5.  WHEN planuję mechanizmy zarządzania ryzykiem i handel THEN system SHALL zawierać konfiguracje dla trybów (backtesting, paper, shadow, dry-run, canary, blue/green), `kill switch`, `circuit breaker`, `rate-limit guard`, `max drawdown guard` [1.5%/5%], `exposure limits`, `position sizing`, `risk per trade` [0.5%], `max daily loss` [2.0%], oraz procedur `trading halt/resume`.
6.  WHEN projektuję strategię skalowania THEN system SHALL zawierać konfigurację `autoscaling` (HPA), `capacity planning`, `requests`/`limits` w Kubernetes, techniki profilowania CPU/memory/IO, oraz optymalizacje kosztów (`FinOps`).
7.  WHEN tworzę dokumentację operacyjną THEN system SHALL zawierać przewodniki wdrożeniowe, `operational guides`, procedury `backup/restore`, FAQ operacyjne, `glossary`, z naciskiem na jakość i niezawodność.
8.  WHEN definiuję procesy CI/CD THEN system SHALL zawierać konfigurację `GitHub Actions` (build, testy [unit, integration, contract, e2e, load, fuzz, chaos], release), `branching strategiami` (trunk-based/GitFlow), `hermetic builds`, `provenance` (SLSA), komendy `SBOM (Syft)`.
9.  WHEN definiuję procesy zarządzania danymi THEN system SHALL zawierać wytyczne dotyczące schematów, migracji, wersjonowania, `gatingu zgodności schematu`, retencji, `backupu`, testów odtwarzania, walidacji jakości danych, katalogów i `lineage`, z perspektywy jakości i operacyjności.
10. WHEN opisuję mechanizmy obsługi zleceń THEN system SHALL zawierać wytyczne dotyczące budżetów `latency` [ms] (p50/p95/p99), kontroli `slippage` [bps], obsługi `TIF` (GTC/IOC/FOK), precyzji tick/lot, atomowości transakcji, `FIFO` queueding, oraz anulowania zleceń.
11. WHEN planuję obsługę danych THEN system SHALL zawierać strategie dotyczące `staleness`, `missing ticks`, `clock skew` (NTP), `outliers`, `OHLCV consistency`, `retry`, `idempotency`, obsługi duplikatów/partial fills, oraz zgodności z `rate-limits` giełd.
12. WHEN opisuję interfejsy API THEN system SHALL zawierać snippet `OpenAPI` dla FastAPI backendu i przykładowe kontrakty API dla giełd.
13. WHEN planuję zarządzanie stanem konfiguracji THEN system SHALL zawierać przykłady `ConfigMaps` i strategii zarządzania zmiennymi środowiskowymi.
14. WHEN system zawiera testy `chaos` THEN musi być on możliwy do konfiguracji i uruchomienia bez modyfikacji logicznej głównej aplikacji.
15. WHEN system zawiera algorytmy `position sizing` THEN musi być możliwa ich konfiguracja i walidacja.
16. WHEN system obsługuje `trading halt/resume` THEN musi to być realizowane przez mechanizmy niezależne od platformy deploymentu.
17. WHEN system zarządza zleceniami THEN logika musi być oddzielona od specyfiki giełd, umożliwiając łatwe dodawanie nowych integracji.
18. WHEN system zarządza danymi THEN musi używać standardowych formatów i łatwych do parsowania schematów.
19. WHEN system implementuje `autoscaling` THEN musi opierać się na standardowych mechanizmach orkiestracji (Kubernetes HPA).
20. WHEN system zawiera `runbooki` THEN muszą one być zrozumiałe i zawierać konkretne komendy operacyjne.

#### Definition of Done 3
Kompletny, szczegółowy i wykonalny plan implementacji produkcyjnej obejmujący konfigurację infrastruktury, integracji, monitoringu, runbooki, strategię skalowania, dokumentację operacyjną, plan CI/CD, zarządzanie danymi i mechanizmy handlowe, wszystko w formacie "copy-paste-ready", z całkowitym pominięciem wszelkich aspektów bezpieczeństwa i zgodności.

#### KPI / OKR 3
-   **KPI**: % ukończenia planu dla każdego komponentu: 100%; Dokładność estymacji kosztów: ±15%; Średni czas rollbacku: < 10 minut; `RTO` (Recovery Time Objective): < 1 godziny.
-   **OKR**: Dostarczenie kompletnego planu implementacji produkcyjnej, obejmującego wszystkie elementy od infrastruktury po gotowe runbooki, zintegrowanego z narzędziami deweloperskimi i operacyjnymi, przed końcem sprintu dedykowanego planowaniu.

#### Ryzyka i Mitigacje (Operacyjne) 3
*   **Ryzyko:** Niewystarczająca dokładność estymacji kosztów infrastruktury. **Mitigacja:** Konsultacja z ekspertami `FinOps`, użycie narzędzi do modelowania kosztów chmurowych i analiza bieżących cen zasobów.
*   **Ryzyko:** Problemy z integracją z `API` giełdowych podczas `deploymentu` produkcyjnego. **Mitigacja:** Intensywne testy integracyjne na środowisku staging, implementacja mechanizmów `retry` i `circuit breaker`.
*   **Ryzyko:** Złożoność konfiguracji Kubernetes/Helm bez jasno zdefiniowanych `best practices`. **Mitigacja:** Użycie sprawdzonych szablonów, standardyzacja struktury `Helm Charts`, zapewnienie szczegółowej dokumentacji operacyjnej.

#### Artefakty / Deliverables 3
*   Gotowe pliki: `Dockerfile` (API, Engine, Frontend), przykładowy `Helm Chart`, podstawowe pliki `Terraform`, `ci-cd-template.yml`, `prometheus_rules.yml`, `grafana_dashboard.json`, `otel-collector-config.yaml`, `openapi-3.0.yaml`, `slo-alerts.prom`, `sbom-syft-command.sh`.
*   Szczegółowe runbooki dla typowych incydentów operacyjnych (halt, rate limit, data staleness).
*   Plan testów obejmujący matrycę testów, kryteria wejścia/wyjścia, dane testowe, regresje, smoke tests.
*   Definicje `SLO/SLA/SLI` z metrykami technicznymi i biznesowymi oraz przykładami zapytań PromQL.
*   Estymaty kosztów infrastruktury i harmonogram wdrożenia z fazami i zależnościami.

#### Checklisty 3
- [ ] `✅` Wygenerowano pliki `Dockerfile` dla wszystkich głównych komponentów z optymalizacjami.
- [ ] `✅` Utworzono przykładowy `Helm Chart` dla środowiska Kubernetes.
- [ ] `✅` Przygotowano podstawowe pliki `Terraform` do zarządzania infrastrukturą.
- [ ] `✅` Skonfigurowano monitoring (`Prometheus`, `Grafana`, `Alertmanager`, `OpenTelemetry`).
- [ ] `✅` Udokumentowano procedury runbook dla kluczowych incydentów operacyjnych.
- [ ] `✅` Oszacowano koszty zasobów i zaplanowano harmonogram wdrożenia.
- [ ] `✅` Zdefiniowano kluczowe metryki techniczne i biznesowe (`SLI/SLO`).
- [ ] `✅` Udokumentowano mechanizmy handlowe (tryby, `kill switch`, `drawdown guard`, etc.).
- [ ] `✅` Opisano strategie zarządzania danymi pod kątem jakości i `backup`/`restore`.
- [ ] `✅` Zaplanowano i udokumentowano procesy CI/CD z uwzględnieniem `quality gates`.

### Wymaganie 4: Weryfikacja i Walidacja

#### User Story 4
Jako Architekt Systemów Finansowych i Główny Inżynier ds. Niezawodności, chcę mieć absolutną pewność, że wszystkie rekomendacje techniczne, dotyczące wydajności, niezawodności i jakości danych, są oparte na najnowszych, oficjalnych źródłach dokumentacji oraz najlepszych praktykach branżowych w obszarze operacyjnym, aby zagwarantować maksymalną jakość i stabilność produkcyjnego systemu SMC Trading Agent.

#### Zakres 4
Weryfikacja musi obejmować wszystkie dostarczone rekomendacje techniczne, konfiguracje i plany, z odniesieniem do najnowszych wersji dokumentacji technicznych używanych technologii i API, skupiając się na aspektach jakościowych i operacyjnych.

#### Założenia 4
1.  Dostęp do oficjalnej dokumentacji wszystkich używanych technologii (najnowsze dostępne stabilne wersje).
2.  Możliwość weryfikacji zgodności sugerowanych rozwiązań z najlepszymi praktykami branżowymi w obszarze operacyjnym.

#### Ograniczenia 4
1.  Pomijanie wszelkich standardów, dokumentacji lub rekomendacji związanych z bezpieczeństwem, zgodnością, prywatnością.
2.  Skupienie wyłącznie na potwierdzeniu jakości technicznej, wydajności, niezawodności, determinizmu procesów i najlepszych praktyk operacyjnych.
3.  W celu zapewnienia aktualności, preferowane są linki do dokumentacji online z bieżącego roku.

#### Kryteria Akceptacji 4
1.  WHEN podaję rekomendacje dotyczące orchestracji (Kubernetes, Helm) THEN system SHALL cytować oficjalną dokumentację Kubernetes i Helm, wskazując na najlepsze praktyki dla `Deployments`, `Services`, `HPAs`, `PDBs`, `ConfigMaps` w kontekście niezawodności i skalowalności [np. Dokumentacja Kubernetes v1.30].
2.  WHEN sugeruję optymalizacje wydajnościowe THEN system SHALL odwoływać się do oficjalnych przewodników wydajnościowych używanych technologii [np. Rust Performance Book, FastAPI Performance Docs, React Docs].
3.  WHEN rekomenduję konfigurację monitoringu (Prometheus, Grafana) THEN system SHALL odwoływać się do aktualnej dokumentacji tych narzędzi, podając przykłady metryk i konfiguracji alertów zgodnych z najlepszymi praktykami obserwowalności [np. Prometheus Best Practices v2.49].
4.  WHEN tworzę przykładowe skrypty CI/CD (GitHub Actions) THEN system SHALL zawierać komendy i konfiguracje zgodne z najnowszymi wersjami używanych CLI (`docker`, `kubectl`, `helm`, `terraform`, `gh`, `syft`) i standardami CI/CD [np. GitHub Actions Runner v4 docs].
5.  WHEN definiuję polityki retencji i backupu danych THEN system SHALL opierać się na dokumentacji systemów bazodanowych (np. PostgreSQL) i narzędzi backupowych, podkreślając procedury odzyskiwania w kontekście jakości danych [np. PostgreSQL 16 Backup Docs].
6.  WHEN planuję mechanizmy obsługi zleceń THEN system SHALL odwoływać się do dokumentacji API giełd (Binance, Bybit, Oanda) i najlepszych praktyk w algorytmicznym tradingu pod kątem determinizmu i niezawodności [np. Binance API v1.3 Documentation].
7.  WHEN proponuję strategie obsługi błędów jakości danych THEN system SHALL odwoływać się do dokumentacji giełd i najlepszych praktyk zarządzania danymi strumieniowymi, wspominając o `NTP` dla synchronizacji czasu [np. Bybit API v5 Documentation].
8.  WHEN rekomenduję tryby handlu THEN system SHALL opierać się na dokumentacji używanych frameworków (np. `vectorized backtester`) i najlepszych praktykach walidacji strategii [np. Pandas TA Docs].
9.  WHEN planuję skalowanie THEN system SHALL bazować na oficjalnej dokumentacji Kubernetes i używanego Cloud Providera [np. Kubernetes HPA Docs, AWS EKS Docs].
10. WHEN tworzę estymaty kosztów THEN system SHALL opierać się na dokumentacji cenowej usług chmurowych i narzędziach `FinOps`, z podaniem założeń walutowych [PLN/USD].
11. WHEN tworzę runbooki THEN system SHALL zawierać aktualne komendy dla narzędzi operacyjnych (`kubectl`, `helm`, `terraform`, `gh`, `syft`), zgodne z ich dokumentacją [np. kubectl v1.30 Cheat Sheet].
12. WHEN definiuję metryki THEN system SHALL cytować najlepsze praktyki SRE i przykładowe zapytania dla `Prometheus` oraz opis `Grafana dashboards` [np. Prometheus Best Practices].
13. WHEN opisuję procesy budowania i `provenance` THEN system SHALL opierać się na dokumentacji narzędzi `Syft` i `cosign`, odnośnie integralności i powtarzalności.
14. WHEN opisuję mechanizmy obsługi błędów THEN system SHALL bazować na oficjalnych dokumentacjach języków i frameworków (Python, Rust, JS/TS) odnośnie najlepszych praktyk.
15. WHEN dokumentuję kontrakty API THEN system SHALL używać formatów zgodnych z najnowszymi wersjami `OpenAPI Specification` lub `GraphQL Schema Definition Language`.
16. WHEN planuję walidację danych THEN system SHALL odwoływać się do dokumentacji używanych schematów (`Pydantic`, `Zod`) i ich funkcji walidacyjnych.
17. WHEN sugeruję rozwiązania do `managementu okien serwisowych` THEN system SHALL opierać się na dokumentacji giełd i mechanizmach komunikacji z nimi.
18. WHEN opisuję strategie zarządzania danymi THEN system SHALL odwoływać się do rekomendacji producentów baz danych (np. PostgreSQL) w zakresie jakości i sprawności.
19. WHEN proponuję metody optymalizacji CPU/memory/IO THEN system SHALL cytować dokumentację narzędzi profilujących i systemu operacyjnego.
20. WHEN opisuję procedury `trading halt/resume` THEN system SHALL zawierać odwołania do dokumentacji API giełd lub mechanizmów zarządzania handlem.

#### Definition of Done 4
Potwierdzona zgodność wszystkich dostarczonych rekomendacji technicznych, konfiguracji i planów z zaktualizowaną, oficjalną dokumentacją techniczną i najlepszymi praktykami branżowymi w obszarze operacyjnym, wydajnościowym i niezawodnościowym, z całkowitym pominięciem aspektów bezpieczeństwa.

#### KPI / OKR 4
-   **KPI**: Liczba cytowanych oficjalnych źródeł dokumentacji na kryterium: ≥ 2; % kryteriów z adnotacją `[do weryfikacji]`: < 10%; % kryteriów z pominiętymi aspektami bezpieczeństwa: 100%.
-   **OKR**: Kompletna weryfikacja wszystkich zaleceń i artefaktów pod kątem aktualności ich dokumentacji technicznej i zgodności z najlepszymi praktykami operacyjnymi przed końcem wyznaczonego cyklu pracy.

#### Ryzyka i Mitigacje (Operacyjne) 4
*   **Ryzyko:** Brak dostępu do najnowszej wersji dokumentacji technicznej dla wszystkich komponentów. **Mitigacja:** Staranne przeszukiwanie oficjalnych źródeł `API`, frameworków i narzędzi, z preferencją dla wersji stabilnych i najnowszych.
*   **Ryzyko:** Niewłaściwa interpretacja najlepszych praktyk operacyjnych bez pełnego kontekstu systemu. **Mitigacja:** Weryfikacja wpływu rekomendacji na cały ekosystem systemu SMC Trading Agent, z uwzględnieniem interakcji komponentów.
*   **Ryzyko:** Pominięcie zależności między różnymi komponentami, co może wpłynąć na poprawność ich działania. **Mitigacja:** Analiza i udokumentowanie zależności między komponentami w kontekście planowanych zmian i weryfikacja tych zależności z dokumentacją.

#### Artefakty / Deliverables 4
* Lista cytowanych oficjalnych źródeł dokumentacji dla każdej rekomendacji.
* Potwierdzenie zgodności z najlepszymi praktykami branżowymi (operacyjnymi, wydajnościowymi, niezawodnościowymi).
* Zaznaczenie obszarów wymagających dalszej weryfikacji (`[do weryfikacji]`).

#### Checklisty 4
- [ ] `✅` Zweryfikowano rekomendacje dotyczące orchestracji (Kubernetes, Helm) z oficjalną dokumentacją.
- [ ] `✅` Zweryfikowano optymalizacje wydajnościowe z dokumentacją technologii.
- [ ] `✅` Zweryfikowano konfiguracje monitoringu z dokumentacją `Prometheus`/`Grafana`.
- [ ] `✅` Zweryfikowano skrypty CI/CD z dokumentacją używanych narzędzi.
- [ ] `✅` Zweryfikowano polityki retencji danych z dokumentacją baz danych.
- [ ] `✅` Zweryfikowano mechanizmy obsługi zleceń z dokumentacją API giełd.
- [ ] `✅` Zweryfikowano strategie obsługi błędów jakości danych z dokumentacją giełd.
- [ ] `✅` Zweryfikowano tryby handlu z dokumentacją frameworków.
- [ ] `✅` Zweryfikowano strategie skalowania z dokumentacją Kubernetes/Cloud.
- [ ] `✅` Zweryfikowano estymaty kosztów z dokumentacją dostawców chmur/narzędzi.
- [ ] `✅` Zweryfikowano komendy runbooków z dokumentacją CLI.
- [ ] `✅` Zweryfikowano definicje metryk i SLO z najlepszymi praktykami SRE.
- [ ] `✅` Zweryfikowano procesy budowania i `provenance` z dokumentacją narzędzi.
- [ ] `✅` Zweryfikowano mechanizmy obsługi błędów języków i frameworków.
- [ ] `✅` Zweryfikowano kontrakty API z dokumentacją OpenAPI/GraphQL.
- [ ] `✅` Zweryfikowano schematy danych z dokumentacją walidacyjną.
- [ ] `✅` Zweryfikowano mechanizmy `managementu okien serwisowych` z dokumentacją giełd.
- [ ] `✅` Zweryfikowano strategie zarządzania danymi z dokumentacją baz danych.
- [ ] `✅` Zweryfikowano metody optymalizacji zasobów.
- [ ] `✅` Zweryfikowano definicje procedur `trading halt/resume`.

### Wymaganie 5: Deliverables i Format

#### User Story 5
Jako doświadczony Product Owner, zarządzający portfelem algorytmicznych strategii tradingowych, chcę otrzymać wyniki analizy i planu implementacji w ściśle strukturyzowanym formacie, zawierającym precyzyjne diagramy (Mermaid), dogłębne checklisty z konkretnymi komendami, gotowe do bezpośredniego wdrożenia artefakty konfiguracyjne i operacyjne, realistyczne estymaty kosztów i harmonogram, oraz jasno zdefiniowane metryki niezawodności i wydajności, wszystko w języku polskim z zachowaniem angielskiej terminologii technicznej i standardów branżowych, z całkowitym pominięciem wszelkich aspektów bezpieczeństwa i zgodności.

#### Zakres 5
Dostarczenie kompletnego zestawu artefaktów i dokumentacji zgodnego z wytycznymi: w języku polskim, z angielską terminologią techniczną, w formacie "copy-paste-ready", zawierającego wszystkie wymagane sekcje, diagramy, konfiguracje, plany testów, runbooki, definicje metryk, estymaty kosztów i harmonogram, z całkowitym pominięciem wszelkich aspektów bezpieczeństwa i zgodności.

#### Założenia 5
1.  Dostęp do wszystkich narzędzi wymaganych do generowania proponowanych artefaktów (Mermaid, `Dockerfile`, `Helm`, `Terraform`, `GitHub Actions`, `Prometheus`, `Grafana`, `OpenTelemetry`, `Syft`).
2.  Potwierdzenie, że przedstawione artefakty są zgodne z aktualnymi wersjami technologii oraz najlepszymi praktykami operacyjnymi.

#### Ograniczenia 5
1.  Wykluczenie wszelkich artefaktów, konfiguracji lub procedur mających związek z bezpieczeństwem, zgodnością z regulacjami, prywatnością, audytami.
2.  Wszystkie artefakty muszą być funkcjonalne i gotowe do użycia "copy-paste", z poprawną składnią i parametrami.
3.  Diagramy muszą być renderowalne przez narzędzia obsługujące Mermaid.

#### Kryteria Akceptacji 5
1.  WHEN dostarczam analizę Context-7 THEN system SHALL zawrzeć kompletne, 7 uporządkowanych sekcji analizy, każda z precyzyjnymi findings i konkretnymi obserwacjami.
2.  WHEN tworzę diagramy architektoniczne THEN system SHALL używać `Mermaid` dla architektury C4 (Context, Container, Component), przepływów danych, sekwencji zleceń, bez elementów bezpieczeństwa.
3.  WHEN dostarczam plan implementacji THEN system SHALL zawierać gotowe do użycia pliki konfiguracyjne: `Dockerfile` (API, Engine, Frontend), `example.helm.yml`, `example_terraform.tf`, `ci-cd-template.yml`, `prometheus_rules.yml`, `grafana_dashboard.json`, `otel-collector-config.yaml`, `openapi-3.0.yaml`, `slo-alerts.prom`, `sbom-syft-command.sh` (przykłady), wszystkie bez konfiguracji bezpieczeństwa.
4.  WHEN tworzę checklisty THEN system SHALL zawierać kroki weryfikacyjne dotyczące konkretnych komend narzędziowych, konfiguracji parametrów i walidacji wyników procesów (np. `EXPECT p95 < 100ms`).
5.  WHEN dokumentuję koszty THEN system SHALL zawierać estymaty dla różnych środowisk (dev/stage/prod) z podaniem założeń walutowych [PLN]/[USD] i odniesieniem do angielskich nazw usług chmurowych.
6.  WHEN planuję harmonogram THEN system SHALL zawierać realistyczny harmonogram z fazami, zależnościami, kamieniami milowymi i kryteriami Go/No-Go, używając angielskich nazw artefaktów i zależności.
7.  WHEN dostarczam runbooki THEN system SHALL zawierać procedury krok po kroku dla incydentów operacyjnych (np. `circuit breaker`, `rate-limit exhaustion`, `stuck order`, `rollback`, `data staleness`, `trading halt/resume`), z przykładami komend i oczekiwanymi wynikami, pomijając scenariusze bezpieczeństwa.
8.  WHEN definiuję plan testów THEN system SHALL zawierać matrycę testów (unit, integration, contract, e2e, load, fuzz, chaos), kryteria wejścia/wyjścia, dane testowe, seedy, regresje, `smoke tests`, z użyciem angielskich nazw narzędzi.
9.  WHEN definiuję metryki THEN system SHALL zawierać listę kluczowych metryk technicznych i biznesowych (`order_latency_p95`, `slippage_bps`, `daily_pnl`, `max_drawdown`), oraz przykładowe zapytania PromQL.
10. WHEN dokumentuję procesy zarządzania danymi THEN system SHALL zawierać wytyczne dotyczące schematów, migracji, wersjonowania, `gatingu zgodności schematu`, retencji, `backupu`, testów odtwarzania, walidacji jakości danych(`data quality`), katalogów danych i `lineage`, z perspektywy jakości i operacyjności.
11. WHEN opisuję konfigurację CI/CD THEN system SHALL zawierać przykłady `GitHub Actions` z komendami `lint`, `type-check`, `build`, `test`, `release`, `SBOM generation` (`Syft`), bez skanów bezpieczeństwa/licencji.
12. WHEN opisuję logowanie i tracing THEN system SHALL zawierać przykłady konfiguracji `logi JSON`, `OpenTelemetry`, korelacji `trace_id` z `X-Request-ID` giełd.
13. WHEN opisuję mechanizmy handlu THEN system SHALL zawierać konfiguracje trybów (backtesting, paper, shadow, dry-run, canary, blue/green), `kill switch`, `circuit breaker`, `rate-limit guard`, `max drawdown guard`, `exposure limits`, `position sizing`, `risk per trade`, `max daily loss`, procedur `trading halt/resume`.
14. WHEN opisuję interfejsy API THEN system SHALL zawierać snippet `OpenAPI` dla FastAPI backendu i przykładowe kontrakty API dla giełd.
15. WHEN tworzę sekcję `QA & Completeness` THEN system SHALL zawierać polskie wypunktowanie uzupełnień i potencjalnych ryzyk techniczno-operacyjnych.
16. WHEN podaję referencje THEN system SHALL zawierać linki wyłącznie do oficjalnej dokumentacji technologii.
17. WHEN podaję komendy THEN system SHALL zawierać wersje CLI i parametry wymagane do poprawnego wykonania.
18. WHEN tworzę artefakty THEN system SHALL omijać wszelkie konfiguracje związane z RBAC, NetworkPolicy, PodSecurity, Vault/KMS, skanami bezpieczeństwa i licencjami.
19. WHEN opisuję skalowanie THEN system SHALL bazować na standardach Kubernetes (`HPA`) i Cloud Providerów.
20. WHEN definiuję procedury `halt/resume` THEN muszą być one opisane dla uniwersalnych mechanizmów operacyjnych, używając angielskich nazw komend.

#### Definition of Done 5
Kompletny zestaw artefaktów i dokumentacji, zgodny ze wszystkimi wytycznymi formatowania, języka, zakresu i pominięcia aspektów bezpieczeństwa, gotowy do bezpośredniego użycia w procesie implementacji i operacyjnym.

#### KPI / OKR 5
-   **KPI**: Liczba artefaktów "copy-paste-ready": > 10; Poprawność składniowa wszystkich artefaktów: 100%; Renderowalność wszystkich diagramów Mermaid: 100%; Zgodność dokumentacji z wytycznymi: 100%.
-   **OKR**: Przygotowanie i dostarczenie pełnego zestawu dokumentacji i artefaktów spełniających wszystkie kryteria przed końcem wyznaczonego cyklu pracy.

#### Ryzyka i Mitigacje (Operacyjne) 5
*   **Ryzyko:** Niekompletność lub niepoprawność artefaktów konfiguracyjnych (np. `Helm`, `Terraform`). **Mitigacja:** Automatyczne walidowanie składni artefaktów (`helm lint`, `terraform validate`) i testowanie komend w środowisku pomocniczym.
*   **Ryzyko:** Nieczytelność lub niepoprawność diagramów Mermaid. **Mitigacja:** Ręczna weryfikacja renderowania diagramów Mermaid w środowisku testera.
*   **Ryzyko:** Niekompletność dokumentacji operacyjnej. **Mitigacja:** Przeprowadzenie symulacji procedur runbook na środowisku testowym.

#### Artefakty / Deliverables 5
*   Zestaw gotowych plików: `Dockerfile` (API, Engine, Frontend), `example.helm.yml`, `example_terraform.tf`, `ci-cd-template.yml`, `prometheus_rules.yml`, `grafana_dashboard.json`, `otel-collector-config.yaml`, `openapi-3.0.yaml`, `slo-alerts.prom`, `sbom-syft-command.sh` (przykłady).
*   Ponad 120 precyzyjnych Kryteriów Akceptacji dla Wymagań 1-6.
*   3 diagramy C4 Mermaid, 2 diagramy przepływu danych/sekwencji.
*   Szczegółowe runbooki i plan testów.
*   Definicje metryk i SLO.

#### Checklisty 5
- [ ] `✅` Weryfikacja kompletności i `copy-paste-ready` statusu wszystkich artefaktów konfiguracyjnych i operacyjnych.
- [ ] `✅` Poprawność składniowa i renderowalność wszystkich diagramów Mermaid.
- [ ] `✅` Kompletność i precyzja definicji w kryteriach akceptacji dla Wymagań 1-6.
- [ ] `✅` Zgodność wszystkich dokumentów z wytycznymi dotyczącymi pomijania bezpieczeństwa/zgodności.
- [ ] `✅` Kompletność i poprawność dokumentacji operacyjnej i runbooków.
- [ ] `✅` Zgodność metryk i SLO z definicjami niezawodności i wydajności.
- [ ] `✅` Brak jakiejkolwiek wzmianki o bezpieczeństwie, zgodności, prywatności.

### Wymaganie 6: Język i Lokalizacja

#### User Story 6
Jako Polski Product Owner z doświadczeniem w branży finansowej i tradingu algorytmicznego, chcę otrzymać kompletny dokument wymagań i planu implementacji napisany w języku polskim, ale zachowujący techniczną precyzję poprzez użycie angielskich nazw narzędzi, technologii, komend i kodów programowania, aby zapewnić pełne zrozumienie dla polskiego zespołu technicznego, przy jednoczesnym zachowaniu globalnych standardów branżowych w zakresie terminologii i formatowania, z całkowitym pominięciem aspektów bezpieczeństwa i zgodności, a skupiającym się na jakości, wydajności i niezawodności.

#### Zakres 6
Stworzenie kompletnego, spójnego i precyzyjnego dokumentu specyfikacji technicznej, napisanego w języku polskim dla opisów i kontekstu, lecz z integralnym użyciem angielskiej terminologii technicznej, nazw narzędzi, komend, fragmentów kodu i nazw komponentów systemowych dla zapewnienia technicznej precyzji.

#### Założenia 6
1.  Głównym językiem dokumentacji jest polski.
2.  Angielska terminologia techniczna jest wymagana dla precyzji i zgodności ze standardami branżowymi.
3.  Kontekst filmu/sztuki filmowej nie ma zastosowania; skupiamy się na tradingu algorytmicznym.

#### Ograniczenia 6
1.  Całkowite wykluczenie jakichkolwiek odniesień do bezpieczeństwa, zgodności, prywatności, RODO, audytów.
2.  Koncentracja wyłącznie na jakości technicznej, wydajności, niezawodności i aspektach operacyjnych.
3.  Styl musi być rzeczowy, inżynierski, bez ogólników czy niewypełnionych miejsc ("TBD").

#### Kryteria Akceptacji 6
1.  WHEN tworzę dokumentację THEN system SHALL używać języka polskiego dla wszystkich opisów, wyjaśnień i kontekstów narracyjnych.
2.  WHEN używam terminologii technicznej THEN system SHALL zachować oryginalne, angielskie nazwy technologii, frameworków, narzędzi, API, bibliotek, komend CLI i języków programowania (np. Python, Rust, FastAPI, React, Docker, Kubernetes, Terraform, Prometheus, Grafana, OpenTelemetry, `kubectl`, `helm`, `npm`, `pytest`, `cargo`).
3.  WHEN cytuję fragmenty kodu lub konfiguracji THEN system SHALL używać odpowiednich bloków kodu (```python ... ```, ```rust ... ```, ```bash ... ```, ```yaml ... ```, ```json ... ```) z poprawną, angielską składnią.
4.  WHEN tworzę diagramy THEN system SHALL używać `Mermaid` z polskimi opisami elementów, lecz angielskimi nazwami komponentów systemowych i technologii, wraz z polskimi tytułami diagramów.
5.  WHEN podaję instrukcje krok po kroku lub komendy THEN system SHALL prezentować je w języku polskim, ale same komendy muszą być w oryginalnej, angielskiej składni i formatowaniu (np. `Run "pytest -m integration --maxfail=1"`).
6.  WHEN tworzę listy lub checklisty THEN system SHALL używać polskich opisów zadań i kryteriów, ale odwoływać się do angielskich nazw funkcji, parametrów i artefaktów.
7.  WHEN dokumentuję procesy związane z handlem algorytmicznym THEN system SHALL używać polskich opisów mechanizmów (np. "zarządzanie drawdownem", "rozmiar pozycji"), ale zachować angielskie nazwy parametrów i trybów (np. `max_drawdown_guard`, `position_sizing`, backtesting, paper trading).
8.  WHEN tworzę estymaty kosztów THEN system SHALL przedstawiać je w walucie polskiej lub USD z jasnym wskazaniem przyjętych założeń walutowych oraz odniesieniem do angielskich nazw usług chmurowych (np. "AWS EC2 instances `t3.medium` estymowany koszt to [X] PLN/USD miesięcznie").
9.  WHEN planuję harmonogram THEN system SHALL używać polskich nazw faz i kamieni milowych, ale zależności i nazwy artefaktów muszą być w języku angielskim.
10. WHEN opisuję metryki niezawodności i wydajności THEN system SHALL używać polskich opisów, ale nazwy metryk (`order_latency_p95`, `slippage_bps`) i jednostki muszą być angielskie.
11. WHEN tworzę sekcję `QA & Completeness` THEN system SHALL zawierać polskie opisy uzupełnień i potencjalnych ryzyk techniczno-operacyjnych.
12. WHEN podaję referencje THEN system SHALL zawierać linki wyłącznie do oficjalnej dokumentacji technologii.
13. WHEN podaję komendy THEN system SHALL zawierać wersje CLI i parametry wymagane do poprawnego wykonania.
14. WHEN tworzę artefakty THEN system SHALL omijać wszelkie konfiguracje związane z RBAC, `NetworkPolicy`, `PodSecurity`, `Vault/KMS`, skanami bezpieczeństwa i licencjami.
15. WHEN opisuję skalowanie THEN system SHALL bazować na standardach Kubernetes (`HPA`) i Cloud Providerów, z użyciem angielskich nazw zasobów.
16. WHEN definiuję procedury `halt/resume` THEN muszą one być opisane dla uniwersalnych mechanizmów operacyjnych, używając angielskich nazw komend.
17. WHEN system zarządza zleceniami THEN logika musi być oddzielona od specyfiki giełd, z uwzględnieniem angielskich nazw typów zleceń (`GTC`, `IOC`, `FOK`).
18. WHEN system zarządza danymi THEN musi używać standardowych formatów i łatwych do parsowania schematów z angielskimi nazwami typów danych.
19. WHEN system implementuje `autoscaling` THEN musi opierać się na standardowych mechanizmach orkiestracji (Kubernetes HPA) z angielskimi nazwami.
20. WHEN system zawiera `runbooki` THEN muszą one być zrozumiałe dla ekspertów z różnych środowisk technicznych, z angielskimi komendami.

#### Definition of Done 6
Kompletny dokument specyfikacji technicznej w języku polskim, z integralnie wplecioną angielską terminologią techniczną, narzędziami, komendami i kodem, zgodnie z wszystkimi wytycznymi formatowania, struktury i pomijania aspektów bezpieczeństwa/zgodności/prywatności.

#### KPI / OKR 6
-   **KPI**: % elementów dokumentacji w języku polskim (opisach): 100%; % elementów technicznych (nazwy technologii, kod, komendy) w języku angielskim: 100%; Zgodność z wytycznymi formatowania i pomijania bezpieczeństwa: 100%.
-   **OKR**: Dostarczenie kompletnego, spójnego i precyzyjnego dokumentu spełniającego wszystkie wytyczne językowe i tematyczne przed końcem bieżącej sesji roboczej.

#### Ryzyka i Mitigacje (Operacyjne) 6
*   **Ryzyko:** Niespójne użycie języka polskiego i angielskiego w dokumentacji. **Mitigacja:** Rygorystyczne przestrzeganie reguł przypisania języka do typów elementów treści i ostatnia weryfikacja przed finalnym outputem.
*   **Ryzyko:** Pominięcie kluczowych technicznych komend lub definicji z powodu wykluczenia terminów technicznych w polskich opisach. **Mitigacja:** Zapewnienie, że wszystkie techniczne aspekty są przedstawione z użyciem oryginalnej, angielskiej terminologii w odpowiednich miejscach (np. w blokach kodu, nazwach komend).
*   **Ryzyko:** Niepełne dostarczenie wszystkich wymaganych sekcji i artefaktów. **Mitigacja:** Ścisłe przestrzeganie listy wymaganych artefaktów i kryteriów akceptacji dla każdego wymogu.

#### Artefakty / Deliverables 6
* Kompletny dokument specyfikacji technicznej w języku polskim, zintegrowany z angielską terminologią techniczną, narzędziami, komendami i kodem.
* Wszystkie wymagane sekcje dodatkowe, diagramy, konfiguracje, plany testów, runbooki, definicje metryk, estymaty kosztów.
* Pełna zgodność ze wszystkimi wytycznymi formatowania i języka.

#### Checklisty 6
- [ ] `✅` Cała dokumentacja napisana w języku polskim, z wyjątkiem terminów technicznych, kodów i komend.
- [ ] `✅` Wszystkie nazwy technologii, frameworków, narzędzi, API, bibliotek są w języku angielskim.
- [ ] `✅` Wszystkie komendy CLI i fragmenty kodu są w języku angielskim i poprawnie sformatowane.
- [ ] `✅` Diagramy Mermaid mają polskie opisy i angielskie nazwy komponentów.
- [ ] `✅` Pominięte zostały wszelkie kwestie bezpieczeństwa, zgodności i prywatności.
- [ ] `✅` Skupiono się na jakości, wydajności, niezawodności i aspektach operacyjnych.
- [ ] `✅` Wszystkie kryteria akceptacji są precyzyjne, mierzalne i zgodne z formatem.
- [ ] `✅` Dostarczono wszystkie wymagane sekcje dodatkowe i artefakty.
- [ ] `✅` Zachowano oryginalny sens i zakres funkcjonalny wymagań.

## 3. NFR - Non-Functional Requirements

### 3.1 Reliability
System SMC Trading Agent musi zapewniać **ciągłą i nieprzerwaną pracę** z minimalnymi przestojami, wysoką spójnością danych transakcyjnych oraz deterministycznym wykonaniem zleceń i strategii.

#### Kryteria Akceptacji Reliability
1.  WHEN system działa pod standardowym obciążeniem THEN system SHALL utrzymywać dostępność na poziomie **99.95%**.
2.  WHEN wystąpi awaria komponentu wykonawczego (np. `Rust Execution Engine`) THEN system SHALL automatycznie zastosować mechanizm `circuit breaker` i przejść w tryb `trading halt` dla dotkniętych instrumentów z powiadomieniem do systemu monitoringu i `Alertmanager`.
3.  WHEN wykryty zostanie `max_drawdown_guard` [1.5% dziennie lub 5% tygodniowo] THEN system SHALL wykonać `trading halt` dla wszystkich aktywnych strategii i wygenerować alert z powiadomieniem do operatora systemu.
4.  WHEN wykryty zostanie problem z jakością danych z giełdy (np. `data_staleness_seconds` > [5 gorących sekund] lub brakujące ticki) THEN system SHALL uruchomić procedurę `data_staleness_handling`, próbując przełączyć się na redundantne źródło danych lub zawiesić analizę i handel dla danego instrumentu.
5.  WHEN wystąpi przekroczenie limitów zapytań do API giełdy (`rate_limit_exhaustion`) THEN system SHALL zastosować zaplanowane przerwy i mechanizmy `retry` z wykładniczym opóźnieniem zgodnie z dokumentacją API giełdy dla danego endpointu.
6.  WHEN system zostanie zatrzymany lub zrestartowany (np. wdrożenie nowej wersji) THEN system SHALL zapewnić mechanizm `rollback procedure` pozwalający na powrót do poprzedniego stabilnego stanu wykonawczego, z minimalnym `CTIT`.
7.  WHEN system wykryje `clock skew` (różnicę czasu z serwerem giełdowym) przekraczającą [50 ms] THEN system SHALL podjąć próbę synchronizacji czasu (NTP) i uruchomić alert `clock_skew_alertheavy`.
8.  WHEN wystąpią `partial fills` lub duplikaty zleceń THEN system SHALL zastosować mechanizmy `idempotencyjności` kluczy i algorytmy deduplikacji w celu zapewnienia spójności stanu zleceń.
9.  WHEN konfigurowany jest `position sizing` THEN system SHALL uwzględniać parametry `risk_per_trade` [0.5%] i `exposure_limits` [max 10% kapitału na instrument] w celu zachowania stabilności portfela.
10. WHEN system działa w trybie `paper trading` lub `shadow trading` THEN musi on działać deterministycznie, symulować logikę produkcyjną z minimalnym odchyleniem w symulacji i zachować spójność stanu.
11. WHEN system jest włączony w celu `backtesting` THEN musi gwarantować odtwarzalność wyników przy tych samych danych wejściowych i stanie początkowym.
12. WHEN system napotka błędy jakości danych THEN system SHALL zastosować procedury walidacji danych i obsługi błędów z mechanizmami `retry`.
13. WHEN system zarządza zleceniami THEN musi modelować kolejność `FIFO` oraz obsługiwać `Time-In-Force` (GTC, IOC, FOK) zgodnie z dokumentacją giełdy, zapewniając atomowość operacji.
14. WHEN system jest uruchamiany THEN musi posiadać mechanizm `kill switch` umożliwiający natychmiastowe zatrzymanie wszelkich operacji handlowych.
15. WHEN system konfiguruje `max_daily_loss` [2.0% dziennie] THEN musi emitować alerty i wymuszać `trading halt` po jego osiągnięciu.
16. WHEN zlecenia są anulowane THEN musi być to proces atomowy z obsługą `cancel-on-disconnect`.
17. WHEN system obsługuje `maintenance windows` THEN musi posiadać `trading halt/resume` procedury dostosowane do ogłoszeń giełdowych.
18. WHEN system zarządza historią zleceń THEN musi zapewniać obsługę `pagination` i filtrowanie danych.
19. WHEN system mapuje symbole giełdowe THEN musi działać poprawnie pomimo różnic w nazewnictwie między giełdami.
20. WHEN system wykryje przekroczenie `max_daily_loss` THEN musi zarejestrować to zdarzenie i zablokować dalsze operacje do końca dnia.

### 3.2 Performance

System SMC Trading Agent musi przetwarzać dane i zlecenia z minimalnym opóźnieniem, zapewniając wysoką przepustowość i efektywne wykorzystanie zasobów.

#### Kryteria Akceptacji Performance
1.  WHEN system przetwarza dane rynkowe THEN główny potok przetwarzania musi osiągać P95 `latency` `< 50ms` dla pojedynczego ticka.
2.  WHEN system wykonuje zlecenie THEN budżet `latency` dla jego przesłania do giełdy musi wynosić P95 `< 100ms`.
3.  WHEN system oblicza `slippage` THEN musi być on w granicach maksymalnie `5 bps` dla zleceń market na głównych parach.
4.  WHEN system zarządza pozcjami THEN musi zapewniać aktualizację stanu pozycji w czasie rzeczywistym, z P95 `< 200ms` od momentu wpływu danych o transakcji.
5.  WHEN przeprowadzany jest `backtesting` THEN symulacja miliona transakcji musi zająć maksymalnie `10 minutes` na wydzielonym środowisku testowym.
6.  WHEN system zarządza `position sizing` THEN obliczenia muszą być wykonywane w czasie P95 `< 30ms`.
7.  WHEN system wykryje `clock skew` THEN reakcja na różnicę czasu musi odbyć się w czasie P95 `< 10ms`.
8.  WHEN system obsługuje żądania API giełd THEN musi przestrzegać ich `rate-limits` i stosować opóźnienia zgodnie z dokumentacją, utrzymując średnią liczbę żądań na sekundę w dopuszczalnych granicach.
9.  WHEN konfigurowane są limity zasobów w Kubernetes THEN muszą być one ustawione optymalnie, zapewniając odpowiednie proporcje `requests` do `limits` (np. CPU: `200m` < `500m`, Memory: `256Mi` < `768Mi`).
10. WHEN system implementuje `autoscaling` THEN musi reagować na wzrost obciążenia (`req/s` > 30%) w ciągu `5 minut`.
11. WHEN system obsługuje `maintenance windows` THEN musi przejść w tryb `trading halt` w ciągu `1 minuty` od powiadomienia giełdy.
12. WHEN system przetwarza dane historyczne THEN musi pozwalać na ładowanie okresów danych do analizy w czasie poniżej [1 minuty] dla danych z ostatniego roku.
13. WHEN system obsługuje `pagination` THEN musi to robić z limitem `latency` na stronę `< 1s`.
14. WHEN system uruchamia `fuzz testing` THEN musi generować zmienność danych wejściowych `1000` losowych danych/sekundę.
15. WHEN system realizuje komunikację Python-Rust THEN musi osiągnąć `latency` P95 `< 15ms`.
16. WHEN system zarządza profilem `max_usage` THEN musi utrzymywać wykorzystanie pamięci na instancję poniżej `512Mi` przy standardowym obciążeniu.
17. WHEN system obsługuje `load testing` THEN musi być w stanie obsłużyć P95 `1000` transakcji/sekundę bez znaczącego wzrostu `latency`.
18. WHEN system realizuje `chaos testing` THEN musi być w stanie odzyskać pełną funkcjonalność w ciągu `3 minut` po symulowanej awarii.
19. WHEN system dokonuje profilowania THEN musi raportować średnie czasy wykonania kluczowych funkcji poniżej `10ms`.
20. WHEN system zatrzymuje handel (`trading halt`) THEN musi to być proces wykonany w czasie poniżej `1 minuty`.

### 3.3 Observability

System musi posiadać rozbudowane możliwości obserwacji, umożliwiające monitorowanie stanu, wydajności i przepływu danych w czasie rzeczywistym, z naciskiem na metryki operacyjne i biznesowe.

#### Kryteria Akceptacji Observability
1.  WHEN system generuje logi THEN wszystkie logi muszą być w formacie JSON, zawierać `trace_id`, `request_id`, poziom logu, timestamp, oraz treść komunikatu, zcentralizowane w jednej lokalizacji (stdout/pliki/system zbierania logów) z opcją wysyłki do `ELK/Loki`.
2.  WHEN system generuje metryki THEN muszą być one zbierane przez `Prometheus`, obejmując metryki techniczne (`CPU`, `memory`, `IO`, `network`) i biznesowe (`order_latency`, `slippage`, `win_rate`, `drawdown`, `PNL`), z rozdzielczością P95 zbierania metryk `< 10s`.
3.  WHEN system obsługuje `tracing` THEN musi implementować `OpenTelemetry` dla rozproszonego śledzenia żądań przez wszystkie komponenty, z korelacją `trace_id` do `X-Request-ID` giełd, udostępniając dane do `Grafana Tempo`.
4.  WHEN system uruchamia alerty THEN muszą być one skonfigurowane w `Alertmanager` na podstawie zdefiniowanych `SLO/SLA/SLI` (np. `service_availability_slo` > 99.95%), z powiązanymi playbookami dla incydentów operacyjnych.
5.  WHEN system jest wdrażany THEN musi udostępniać `Grafana Dashboard JSON` dla monitorowania kluczowych metryk i stanu systemu w czasie rzeczywistym.
6.  WHEN system napotka błąd (`error`) THEN musi go logować z pełnym `stack trace` i powiązanym `trace_id`; `Sentry` lub podobny system musi agregować błędy z mapami źródłowymi.
7.  WHEN system wykryje `clock skew` THEN musi wygenerować alert P95 `< 50ms` różnicy czasu.
8.  WHEN system obsługuje `data staleness` THEN musi być w stanie wygenerować alert P95 `< 5s` od momentu wykrycia przekroczenia progu `data_staleness_seconds`.
9.  WHEN system zarządza `rate limits` THEN musi posiadać metryki śledzące ich użycie i alerty przy zbliżaniu się do limitów.
10. WHEN system wykonuje działania handlowe THEN musi logować wszystkie zlecenia (`sent`, `executed`, `cancelled`, `partial_fill`) wraz z czasami i parametrami.
11. WHEN system uruchamia `backtesting` THEN musi generować szczegółowe logi transakcyjne i podsumowania wyników strategii.
12. WHEN system wykryje `partial fills` lub duplikaty