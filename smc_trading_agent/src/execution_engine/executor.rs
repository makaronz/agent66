use rust_decimal::Decimal;
use uuid::Uuid;
use thiserror::Error;
use ccxt_rs::{Exchange, ExchangeConfig, OrderType as CcxtOrderType, Side as CcxtSide};
use circuit_breaker::{CircuitBreaker, CircuitBreakerConfig};
use metrics::{counter, histogram, gauge};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::time::{Duration, Instant};
use tracing::{info, warn, error, instrument};

/// Represents a trading signal generated by the decision engine.
#[derive(Debug, Clone)]
pub struct Signal {
    pub id: Uuid,
    pub exchange: String,
    pub symbol: String,
    pub action: Action,
    pub price: Option<Decimal>, // For limit/stop orders
    pub quantity: Decimal,
    pub order_type: OrderType,
}

/// Defines the type of action to be taken.
#[derive(Debug, Clone, PartialEq)]
pub enum Action {
    Buy,
    Sell,
}

/// Defines the type of order to be placed.
#[derive(Debug, Clone, PartialEq)]
pub enum OrderType {
    Market,
    Limit,
}

/// Represents a concrete order to be sent to an exchange.
#[derive(Debug, Clone)]
pub struct Order {
    pub id: Uuid,
    pub signal_id: Uuid,
    pub exchange: String,
    pub symbol: String,
    pub action: Action,
    pub price: Option<Decimal>,
    pub quantity: Decimal,
    pub order_type: OrderType,
    pub status: OrderStatus,
    pub execution_time: Option<Duration>,
    pub exchange_order_id: Option<String>,
}

/// Represents the status of an order.
#[derive(Debug, Clone, PartialEq)]
pub enum OrderStatus {
    New,
    Pending,
    Filled,
    PartiallyFilled,
    Cancelled,
    Failed,
}

/// Custom error types for the execution engine.
#[derive(Error, Debug)]
pub enum ExecutionError {
    #[error("Failed to connect to exchange: {0}")]
    ConnectionError(String),
    #[error("Exchange API error: {0}")]
    ApiError(String),
    #[error("Invalid trading signal: {0}")]
    InvalidSignal(String),
    #[error("Insufficient funds for order: {0}")]
    InsufficientFunds(String),
    #[error("Risk limit exceeded: {0}")]
    RiskLimitExceeded(String),
    #[error("Order execution failed: {0}")]
    ExecutionFailed(String),
    #[error("Circuit breaker open: {0}")]
    CircuitBreakerOpen(String),
    #[error("Timeout error: {0}")]
    TimeoutError(String),
    #[error("An unknown error occurred")]
    Unknown,
}

/// Configuration for the OrderExecutor
#[derive(Debug, Clone)]
pub struct OrderExecutorConfig {
    pub max_retries: u32,
    pub retry_delay_ms: u64,
    pub timeout_ms: u64,
    pub circuit_breaker_failure_threshold: u32,
    pub circuit_breaker_recovery_timeout_ms: u64,
    pub latency_threshold_ms: u64,
}

impl Default for OrderExecutorConfig {
    fn default() -> Self {
        Self {
            max_retries: 3,
            retry_delay_ms: 100,
            timeout_ms: 5000,
            circuit_breaker_failure_threshold: 5,
            circuit_breaker_recovery_timeout_ms: 30000,
            latency_threshold_ms: 50,
        }
    }
}

/// High-performance order executor with CCXT integration and latency monitoring
pub struct OrderExecutor {
    exchange_clients: Arc<RwLock<HashMap<String, Exchange>>>,
    circuit_breakers: Arc<RwLock<HashMap<String, CircuitBreaker>>>,
    config: OrderExecutorConfig,
    metrics_enabled: bool,
}

impl OrderExecutor {
    /// Create a new OrderExecutor with default configuration
    pub fn new() -> Self {
        Self::with_config(OrderExecutorConfig::default())
    }

    /// Create a new OrderExecutor with custom configuration
    pub fn with_config(config: OrderExecutorConfig) -> Self {
        info!("Initializing OrderExecutor with config: {:?}", config);
        
        Self {
            exchange_clients: Arc::new(RwLock::new(HashMap::new())),
            circuit_breakers: Arc::new(RwLock::new(HashMap::new())),
            config,
            metrics_enabled: true,
        }
    }

    /// Initialize exchange client for a specific exchange
    #[instrument(skip(self))]
    pub async fn initialize_exchange(&self, exchange_name: &str, api_key: Option<String>, secret: Option<String>) -> Result<(), ExecutionError> {
        let start_time = Instant::now();
        
        info!("Initializing exchange client for: {}", exchange_name);
        
        let config = ExchangeConfig {
            api_key,
            secret,
            ..Default::default()
        };

        match Exchange::new(exchange_name, config) {
            Ok(exchange) => {
                let mut clients = self.exchange_clients.write().await;
                clients.insert(exchange_name.to_string(), exchange);
                
                // Initialize circuit breaker for this exchange
                let circuit_config = CircuitBreakerConfig {
                    failure_threshold: self.config.circuit_breaker_failure_threshold,
                    recovery_timeout: Duration::from_millis(self.config.circuit_breaker_recovery_timeout_ms),
                    ..Default::default()
                };
                
                let mut breakers = self.circuit_breakers.write().await;
                breakers.insert(exchange_name.to_string(), CircuitBreaker::new(circuit_config));
                
                let duration = start_time.elapsed();
                histogram!("exchange_initialization_duration_ms", duration.as_millis() as f64);
                counter!("exchange_initializations_total", 1);
                
                info!("Exchange {} initialized successfully in {:?}", exchange_name, duration);
                Ok(())
            }
            Err(e) => {
                error!("Failed to initialize exchange {}: {:?}", exchange_name, e);
                counter!("exchange_initialization_failures_total", 1);
                Err(ExecutionError::ConnectionError(format!("Failed to initialize {}: {:?}", exchange_name, e)))
            }
        }
    }

    /// Execute an SMC trading signal with comprehensive error handling and monitoring
    #[instrument(skip(self, signal))]
    pub async fn execute_smc_signal(&self, signal: Signal) -> Result<Order, ExecutionError> {
        let start_time = Instant::now();
        
        info!("Executing SMC signal: {:?}", signal.id);
        counter!("smc_signals_executed_total", 1);

        // 1. Validate the incoming signal
        self.validate_signal(&signal)?;

        // 2. Check circuit breaker status
        self.check_circuit_breaker(&signal.exchange).await?;

        // 3. Create an Order from the Signal
        let mut order = Order {
            id: Uuid::new_v4(),
            signal_id: signal.id,
            exchange: signal.exchange.clone(),
            symbol: signal.symbol.clone(),
            action: signal.action.clone(),
            price: signal.price,
            quantity: signal.quantity,
            order_type: signal.order_type.clone(),
            status: OrderStatus::New,
            execution_time: None,
            exchange_order_id: None,
        };

        // 4. Execute the order with retry logic
        let execution_result = self.execute_order_with_retry(&mut order).await;
        
        let total_duration = start_time.elapsed();
        order.execution_time = Some(total_duration);
        
        // Record metrics
        histogram!("order_execution_duration_ms", total_duration.as_millis() as f64);
        
        if total_duration.as_millis() > self.config.latency_threshold_ms {
            warn!("Order execution exceeded latency threshold: {:?} > {}ms", 
                  total_duration, self.config.latency_threshold_ms);
            counter!("order_execution_latency_threshold_exceeded_total", 1);
        }

        match execution_result {
            Ok(_) => {
                counter!("orders_executed_successfully_total", 1);
                info!("Order executed successfully: {:?} in {:?}", order.id, total_duration);
                Ok(order)
            }
            Err(e) => {
                counter!("orders_execution_failed_total", 1);
                error!("Order execution failed: {:?} - {:?}", order.id, e);
                order.status = OrderStatus::Failed;
                Err(e)
            }
        }
    }

    /// Execute a single order with retry logic and circuit breaker
    #[instrument(skip(self, order))]
    async fn execute_order_with_retry(&self, order: &mut Order) -> Result<(), ExecutionError> {
        let mut last_error = None;
        
        for attempt in 0..=self.config.max_retries {
            let attempt_start = Instant::now();
            
            match self.execute_single_order(order).await {
                Ok(_) => {
                    let attempt_duration = attempt_start.elapsed();
                    histogram!("order_execution_attempt_duration_ms", attempt_duration.as_millis() as f64);
                    
                    if attempt > 0 {
                        info!("Order executed successfully on attempt {}", attempt + 1);
                        counter!("order_execution_retry_success_total", 1);
                    }
                    return Ok(());
                }
                Err(e) => {
                    last_error = Some(e.clone());
                    let attempt_duration = attempt_start.elapsed();
                    
                    warn!("Order execution attempt {} failed: {:?} in {:?}", 
                          attempt + 1, e, attempt_duration);
                    
                    counter!("order_execution_attempt_failed_total", 1);
                    histogram!("order_execution_failed_attempt_duration_ms", attempt_duration.as_millis() as f64);
                    
                    // Update circuit breaker
                    self.record_failure(&order.exchange).await;
                    
                    if attempt < self.config.max_retries {
                        let delay = Duration::from_millis(self.config.retry_delay_ms * (attempt + 1) as u64);
                        tokio::time::sleep(delay).await;
                    }
                }
            }
        }
        
        Err(last_error.unwrap_or(ExecutionError::Unknown))
    }

    /// Execute a single order on the exchange
    #[instrument(skip(self, order))]
    async fn execute_single_order(&self, order: &mut Order) -> Result<(), ExecutionError> {
        let clients = self.exchange_clients.read().await;
        let exchange = clients.get(&order.exchange)
            .ok_or_else(|| ExecutionError::ConnectionError(format!("Exchange {} not initialized", order.exchange)))?;

        // Convert our order types to CCXT types
        let ccxt_side = match order.action {
            Action::Buy => CcxtSide::Buy,
            Action::Sell => CcxtSide::Sell,
        };

        let ccxt_order_type = match order.order_type {
            OrderType::Market => CcxtOrderType::Market,
            OrderType::Limit => CcxtOrderType::Limit,
        };

        // Prepare order parameters
        let mut params = HashMap::new();
        if let Some(price) = order.price {
            params.insert("price".to_string(), price.to_string());
        }

        // Execute the order with timeout
        let execution_future = exchange.create_order(
            &order.symbol,
            ccxt_order_type,
            ccxt_side,
            order.quantity.to_string(),
            params,
        );

        let timeout_duration = Duration::from_millis(self.config.timeout_ms);
        let result = tokio::time::timeout(timeout_duration, execution_future).await;

        match result {
            Ok(Ok(ccxt_order)) => {
                order.status = OrderStatus::Pending;
                order.exchange_order_id = Some(ccxt_order.id);
                
                // Update circuit breaker on success
                self.record_success(&order.exchange).await;
                
                info!("Order placed successfully: exchange_id={:?}, our_id={:?}", 
                      order.exchange_order_id, order.id);
                Ok(())
            }
            Ok(Err(e)) => {
                error!("Exchange API error: {:?}", e);
                Err(ExecutionError::ApiError(format!("Exchange error: {:?}", e)))
            }
            Err(_) => {
                error!("Order execution timeout after {}ms", self.config.timeout_ms);
                Err(ExecutionError::TimeoutError(format!("Order execution timeout after {}ms", self.config.timeout_ms)))
            }
        }
    }

    /// Validate trading signal
    fn validate_signal(&self, signal: &Signal) -> Result<(), ExecutionError> {
        if signal.quantity <= Decimal::ZERO {
            return Err(ExecutionError::InvalidSignal("Quantity must be positive.".to_string()));
        }

        if signal.order_type == OrderType::Limit && signal.price.is_none() {
            return Err(ExecutionError::InvalidSignal("Limit orders must have a price.".to_string()));
        }

        if signal.exchange.is_empty() {
            return Err(ExecutionError::InvalidSignal("Exchange must be specified.".to_string()));
        }

        if signal.symbol.is_empty() {
            return Err(ExecutionError::InvalidSignal("Symbol must be specified.".to_string()));
        }

        Ok(())
    }

    /// Check circuit breaker status for exchange
    async fn check_circuit_breaker(&self, exchange: &str) -> Result<(), ExecutionError> {
        let breakers = self.circuit_breakers.read().await;
        if let Some(circuit_breaker) = breakers.get(exchange) {
            if !circuit_breaker.is_closed() {
                error!("Circuit breaker is open for exchange: {}", exchange);
                counter!("circuit_breaker_open_total", 1);
                return Err(ExecutionError::CircuitBreakerOpen(format!("Circuit breaker open for {}", exchange)));
            }
        }
        Ok(())
    }

    /// Record failure in circuit breaker
    async fn record_failure(&self, exchange: &str) {
        let mut breakers = self.circuit_breakers.write().await;
        if let Some(circuit_breaker) = breakers.get_mut(exchange) {
            circuit_breaker.record_failure();
            counter!("circuit_breaker_failures_total", 1);
        }
    }

    /// Record success in circuit breaker
    async fn record_success(&self, exchange: &str) {
        let mut breakers = self.circuit_breakers.write().await;
        if let Some(circuit_breaker) = breakers.get_mut(exchange) {
            circuit_breaker.record_success();
            counter!("circuit_breaker_successes_total", 1);
        }
    }

    /// Cancel an existing order
    #[instrument(skip(self))]
    pub async fn cancel_order(&self, exchange: &str, order_id: &str) -> Result<(), ExecutionError> {
        let start_time = Instant::now();
        
        info!("Cancelling order: {} on exchange: {}", order_id, exchange);
        counter!("order_cancellations_attempted_total", 1);

        let clients = self.exchange_clients.read().await;
        let exchange_client = clients.get(exchange)
            .ok_or_else(|| ExecutionError::ConnectionError(format!("Exchange {} not initialized", exchange)))?;

        let cancellation_future = exchange_client.cancel_order(order_id);
        let timeout_duration = Duration::from_millis(self.config.timeout_ms);
        
        let result = tokio::time::timeout(timeout_duration, cancellation_future).await;

        let duration = start_time.elapsed();
        histogram!("order_cancellation_duration_ms", duration.as_millis() as f64);

        match result {
            Ok(Ok(_)) => {
                counter!("order_cancellations_successful_total", 1);
                info!("Order cancelled successfully: {} in {:?}", order_id, duration);
                Ok(())
            }
            Ok(Err(e)) => {
                counter!("order_cancellations_failed_total", 1);
                error!("Failed to cancel order {}: {:?}", order_id, e);
                Err(ExecutionError::ApiError(format!("Cancellation failed: {:?}", e)))
            }
            Err(_) => {
                counter!("order_cancellations_timeout_total", 1);
                error!("Order cancellation timeout after {}ms", self.config.timeout_ms);
                Err(ExecutionError::TimeoutError(format!("Cancellation timeout after {}ms", self.config.timeout_ms)))
            }
        }
    }

    /// Get order status from exchange
    #[instrument(skip(self))]
    pub async fn get_order_status(&self, exchange: &str, order_id: &str) -> Result<OrderStatus, ExecutionError> {
        let start_time = Instant::now();
        
        let clients = self.exchange_clients.read().await;
        let exchange_client = clients.get(exchange)
            .ok_or_else(|| ExecutionError::ConnectionError(format!("Exchange {} not initialized", exchange)))?;

        let status_future = exchange_client.fetch_order(order_id);
        let timeout_duration = Duration::from_millis(self.config.timeout_ms);
        
        let result = tokio::time::timeout(timeout_duration, status_future).await;

        let duration = start_time.elapsed();
        histogram!("order_status_fetch_duration_ms", duration.as_millis() as f64);

        match result {
            Ok(Ok(ccxt_order)) => {
                let status = match ccxt_order.status.as_str() {
                    "open" => OrderStatus::Pending,
                    "closed" => OrderStatus::Filled,
                    "canceled" => OrderStatus::Cancelled,
                    "partially_filled" => OrderStatus::PartiallyFilled,
                    _ => OrderStatus::Failed,
                };
                
                counter!("order_status_fetches_successful_total", 1);
                Ok(status)
            }
            Ok(Err(e)) => {
                counter!("order_status_fetches_failed_total", 1);
                error!("Failed to fetch order status: {:?}", e);
                Err(ExecutionError::ApiError(format!("Status fetch failed: {:?}", e)))
            }
            Err(_) => {
                counter!("order_status_fetches_timeout_total", 1);
                error!("Order status fetch timeout after {}ms", self.config.timeout_ms);
                Err(ExecutionError::TimeoutError(format!("Status fetch timeout after {}ms", self.config.timeout_ms)))
            }
        }
    }

    /// Get performance metrics
    pub fn get_metrics(&self) -> HashMap<String, f64> {
        let mut metrics = HashMap::new();
        
        if self.metrics_enabled {
            // This would typically collect metrics from the metrics crate
            // For now, we'll return a placeholder
            metrics.insert("orders_executed_total".to_string(), 0.0);
            metrics.insert("average_execution_latency_ms".to_string(), 0.0);
            metrics.insert("circuit_breaker_failures_total".to_string(), 0.0);
        }
        
        metrics
    }
}
